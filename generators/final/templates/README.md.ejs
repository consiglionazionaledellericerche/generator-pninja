<%
const csvsE = entities.map(({name}) => `${name}.csv # Data for ${name} entity`);
const csvsR = relationships?.filter(({ cardinality }) => cardinality === 'ManyToMany').map(({from, to}) => `${from.name}_${to.name}.csv # Many-to-many relationship from ${from.name} to ${to.name}`) || [];
const csvs = [...csvsE, ...csvsR];
-%>
# <%= appName %>

**Application generated successfully with ♥️ & [PNinja][pninja-url]!**

Set up the **database**, the **Keycloak server**, and any required **search engine** in `server/.env` before starting the server and client.

Start your **development REST API server** (http://127.0.0.1:8000/api/health) with:

```sh
npm run server
```

Start your **development client** (http://localhost:5173/) with:

```sh
npm run client
```

Alternatively, you can start both the **development client and server** with:

```sh
npm run dev
```

To **initialize** the **database**:

```sh
npm run migrate # or npm run migrate:fresh or npm run migrate:fresh:seed
```

<%  if (['solr','meilisearch','elastic','algolia','typesense'].includes(searchEngine)) { -%>
To **initialize** the **search engine**:

```sh
# server/.env
<%      if (searchEngine === 'algolia') { -%>
ALGOLIA_APP_ID=YOUR_ALGOLIA_APP_ID
ALGOLIA_SECRET=YOUR_ALGOLIA_SECRET
<%      } -%>
<%      if (searchEngine === 'elastic') { -%>
ELASTIC_HOST=http://localhost:9200
<%      } -%>
<%      if (searchEngine === 'meilisearch') { -%>
MEILISEARCH_HOST=http://localhost:7700
MEILISEARCH_KEY=meilisearch-master-key
<%      } -%>
<%      if (searchEngine === 'typesense') { -%>
TYPESENSE_API_KEY=xyz
TYPESENSE_HOST=localhost
TYPESENSE_PORT=8108
TYPESENSE_PROTOCOL=http
<%      } -%>
<%      if (searchEngine === 'solr') { -%>
SOLR_HOST=localhost
SOLR_PORT=8983
SOLR_PATH=/
<%      } -%>
```
<%      if (['solr','meilisearch','elastic'].includes(searchEngine)) { -%>

```sh
<%          if (searchEngine === 'elastic') { -%>
npm run elastic:migrate
<%          } -%>
<%          if (searchEngine === 'meilisearch') { -%>
npm run scout:sync-index-settings
<%          } -%>
<%          if (searchEngine === 'solr') { -%>
cd server
<%- entities.map(({name}) => `php artisan scout:index "App\\Models\\${name}"`).join('\n');%>
<%          } -%>
```
<%      } -%>
<%  } -%>
## Database Seeding: CSV vs Factory

To populate the database with **test records**:

```sh
npm run db:seed
```

Seeding supports two modes, **mutually exclusive** for each entity:

### 1. **CSV Mode** (controlled and reproducible data)

If a CSV file exists in `server/database/seeders/csv/`, **only** data from the CSV is loaded:

```sh
server/database/seeders/csv/
├── AcRule.csv # Rules for access control
<% csvs.map((row, i) => {-%>
<%- i < (csvs.length - 1) ? '├──' : '└──' %> <%- row %>
<%}); -%>
```

**CSV format for entities:**
```csv
column_a,column_b,column_c,column_d,related_id
colA001,colB001,colC001,colD001,1
colA002,colB002,colC002,colD002,2
colA003,colB003,colC003,colD003,3
```

**CSV format for many-to-many relationships:**
```csv
model_id,related_id
1,1
1,2
2,3
```

- First row contains database column names
- Empty fields are ignored
- Completely empty rows are skipped
- Foreign keys must reference existing IDs

### 2. **Factory Mode** (random data)

If the CSV file **does not exist**, random data is generated using Laravel factories.

The number of entities generated depends on the answer provided during the project generation phase to the question:

```
? How many entities to generate for each entity (factories)? (30)
```

### Which mode to use?

- **CSV**: for stable test data, demos, or when full control over data is needed
- **Factory**: for rapid development with random but realistic data
- **Mix**: some entities from CSV, others from factory (each entity chooses independently)

## Access Control with Casbin

The application uses **[Casbin](https://casbin.org/)** for **role-based access control (RBAC)**. Casbin enforces authorization policies that determine which users can perform specific actions on resources.

**How it works:**

- **Policies** are stored in the `ac_rules` database table
- **Model** is defined in `server/config/lauthz-rbac-model.conf`
- **Enforcement** happens automatically via middleware on both backend and frontend

**Default roles and permissions:**

- **`superadmin`**: Full access to all resources and does not require policies based on the model in `server/config/lauthz-rbac-model.conf`
- **`__AUTHUSER__`**: Authenticated users can perform all actions on generated entities
- **`__GUEST__`**: Unauthenticated users have read-only access to generated entities

**Policy format:**
```csv
ptype,v0,v1,v2
p,role,resource,action
g,username,role
```

Where:
- `p` = permission rule (role can perform action on resource)
- `g` = role assignment (user has role)

**Examples:**
```csv
<% if (entities.length > 0) { -%>
p,__AUTHUSER__,<%- entities[0].name %>,create
p,__AUTHUSER__,<%- entities[0].name %>,read
p,__AUTHUSER__,<%- entities[0].name %>,update
p,__AUTHUSER__,<%- entities[0].name %>,delete
<% } -%>
<% if (entities.length > 1) { -%>
p,__AUTHUSER__,<%- entities[1].name %>,create
p,__AUTHUSER__,<%- entities[1].name %>,read
p,__AUTHUSER__,<%- entities[1].name %>,update
p,__AUTHUSER__,<%- entities[1].name %>,delete
<% } -%>
<% if (entities.length > 0) { -%>
p,__GUEST__,<%- entities[0].name %>,read
<% } -%>
<% if (entities.length > 1) { -%>
p,__GUEST__,<%- entities[1].name %>,read
<% } -%>
p,admin,AcRule,create
p,admin,AcRule,read
p,admin,AcRule,update
p,admin,AcRule,delete
g,john.doe,superadmin
g,emma.johnson,admin
```

**Custom roles and permissions:**

To modify permissions, edit the `ac_rules` table or use the admin interface at `/entities/ac-rules`.

To assign the first role `superadmin`, or any other role, to a user, you can use:

```sh
cd ./server/
php artisan add-role superadmin <username>
php artisan add-role admin <another_username>
```

## Audit Logging

The application includes **comprehensive audit logging** powered by **[Laravel Auditing](https://laravel-auditing.com/)**. All CRUD operations (create, update, delete, restore) on Eloquent models are automatically tracked and stored in the `audits` table.

**Features:**

- **Automatic tracking**: All changes to auditable models are logged without additional code
- **Complete history**: Old and new values are stored for every change
- **User attribution**: Each audit record includes the username from Keycloak
- **Metadata**: IP address, user agent, URL, and timestamp are captured
- **Multi-database support**: Works with MySQL, PostgreSQL, and SQLite

**Audit Dashboard:**

Access the audit interface at `/audits` with two tabs:

1. **Audit Logs**: Browse, search, and filter all audit records
   - Search by model, event, user, date range
   - View detailed changes (old vs new values)
   - Compare specific changes side-by-side
   - View complete history for any entity

2. **Statistics**: Visual analytics and insights
   - Activity timeline with automatic granularity (hours/days/months/years)
   - Events breakdown (created/updated/deleted/restored)
   - Most modified models
   - Top active users

**Access control:**

By default, **only `superadmin` role** can access the audit system. To grant access to other users, add policies to the `ac_rules` table:

```csv
p,admin,Audit,read
p,auditor,Audit,read
g,jane.smith,auditor
```

**Available resources and actions:**
- Resource: `Audit`
- Actions: `read` (view logs and statistics)

**Technical details:**

- All timestamps are stored in **UTC** for global consistency
- Audit data is never automatically deleted (retention policy must be implemented manually if needed)
- The `user_id` field stores the Keycloak username (not a database ID)
- Audit records are immutable once created

**Performance considerations:**

For high-traffic applications, consider:
- Periodic archival of old audit records
- Indexing the `audits` table on frequently queried columns
- Using a separate database for audit data

## Docker composition

To start the **Docker composition**:

```sh
cd ./docker/
docker compose up --build
```

If you don't have the databases or search engines required for development, you can refer to the `docker/docker-compose.yml` file to start development containers.

[pninja-url]: https://pninja.tech