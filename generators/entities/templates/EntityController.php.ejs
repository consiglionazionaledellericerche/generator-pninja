<?php
<%
function isEmpty(obj) {
  for (let key in obj) {
    return false;
  }
  return true;
}
-%>
namespace App\Http\Controllers;

use App\Models\<%- className %>;
<%  if (relatedEntitiesForFilters && relatedEntitiesForFilters.length) {-%>
<%      relatedEntitiesForFilters.map(({name}) => {-%>
use App\Models\<%- name %>;
<%      })-%>
<%  }-%>
use App\Traits\HandlesApiErrors;
// use App\Traits\HandlesUserRoles;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Validation\Rule;

class <%- className %>Controller extends Controller
{
    use HandlesApiErrors;
    // use HandlesUserRoles;

    // private $viewerRole = 'viewer';

    public function index(Request $request)
    {
        try {
            // if (!$this->userHasRole($this->viewerRole)) return response()->json(['error' => 'Forbidden'], 403);
            $query = <%- className %>::query();
<%  if (relatedEntitiesForFilters && relatedEntitiesForFilters.length) {-%>
<%      relatedEntitiesForFilters.map(({name, injectedField}) =>{-%>
            if ($request->has('available_for_<%-to.snake(name)%>')) {
                $<%-to.camel(name)%>Id = $request->query('available_for_<%-to.snake(name)%>');
                $associatedIds = <%-name%>::whereNotNull('<%-to.snake(injectedField)%>_id')
                    ->when($<%-to.camel(name)%>Id, function($query) use ($<%-to.camel(name)%>Id) {
                        return $query->where('id', '!=', $<%-to.camel(name)%>Id);
                    })
                    ->pluck('<%-to.snake(injectedField)%>_id');
                $query->whereNotIn('id', $associatedIds);
            }
<%      })-%>
<%  }-%>
<%          if (withs) { -%>
            $result = $query->with(<%- withs %>)->get();
<%          } else { -%>
            $result = $query->get();
<%          } -%>
            return response()->json($result);
        } catch (\Exception $e) {
            return $this->handleIndexError($e);
        }
    }

    public function show($id)
    {
        try {
<%          if (withs) { -%>
            return response()->json(<%- className %>::with(<%- withs %>)->findOrFail($id));
<%          } else { -%>
            return response()->json(<%- className %>::findOrFail($id));
<%          } -%>
        } catch (\Exception $e) {
            return $this->handleShowError($e);
        }
    }

    public function store(Request $request)
    {
        try {
<%  if(isEmpty(validationsStore)) {-%>
            $data = $request->all();
<%  } else {-%>
            $validated = $request->validate([
<%      for (field in validationsStore) {-%>
                '<%- field %>' => [
<%          validationsStore[field].forEach(validation => {-%>
                    <%- validation -%>,
<%          })-%>
                ],
<%      }-%>
            ]);
            $data = $validated;
<%  }-%>
<%          fileFields.forEach((field) => {-%>
            if($request->input('<%-to.snake(field)%>.data')) {
                $fileData = base64_decode($request->input('<%-to.snake(field)%>.data'));
                $mimeType = $request->input('<%-to.snake(field)%>.mimeType');
                $originalName = $request->input('<%-to.snake(field)%>.originalName');
                $filename = uniqid() . '-' . $originalName;
                $path = 'uploads/' . date('Y/m/d') . '/' . $filename;
                $stored = Storage::disk('private')->put($path, $fileData);
                if($stored) {
                    $data['<%-to.snake(field)%>_path'] = $path;
                    $data['<%-to.snake(field)%>_type'] = $mimeType;
                    $data['<%-to.snake(field)%>_name'] = $originalName;
                }
            }
<%    });-%>

            $<%- entityName %> = <%- className %>::create($data);
<%          if (createRelated) { -%>
<%- createRelated.split("\n").filter(line => !line.endsWith("// only-update")).join("\n") %>
<%          } -%>
<%          if (withs) { -%>
            $<%- entityName %> = <%- className %>::with(<%- withs %>)->findOrFail($<%- entityName %>->id);
<%          } -%>
            return response()->json($<%- entityName %>, 201);
        } catch (\Exception $e) {
            return $this->handleCreateError($e);
        }
    }
    public function update($id, Request $request)
    {
        try {
<%          if (withs) { -%>
            $<%- entityName %> = <%- className %>::with(<%- withs %>)->findOrFail($id);
<%          } else { -%>
            $<%- entityName %> = <%- className %>::findOrFail($id);
<%          } -%>
<%  if(isEmpty(validationsUpdate)) {-%>
            $data = $request->all();
<%  } else {-%>
            $validated = $request->validate([
<%      for (field in validationsUpdate) {-%>
                '<%- field %>' => [
<%          validationsUpdate[field].forEach(validation => {-%>
                    <%- validation -%>,
<%          })-%>
                ],
<%      }-%>
            ]);
            $data = $validated;
<%  }-%>
<%  if(!isEmpty(fileFields)) {-%>
            $filesToDelete = $request->input('filesToDelete', []);
            $filesToDeletePaths = array_map(fn($field): string => $<%- entityName %>[$field . '_path'] ?? null, $filesToDelete);
            foreach ($filesToDelete as $field) {
                $<%- entityName %>[$field . '_path'] = null;
                $<%- entityName %>[$field . '_type'] = null;
                $<%- entityName %>[$field . '_name'] = null;
            }
<%      fileFields.forEach((field) => {-%>
            if($request->input('<%-to.snake(field)%>.data')) {
                if ($<%- entityName %>-><%-to.snake(field)%>_path) {
                    Storage::disk('private')->delete($<%- entityName %>-><%-to.snake(field)%>_path);
                }
                $fileData = base64_decode($request->input('<%-to.snake(field)%>.data'));
                $mimeType = $request->input('<%-to.snake(field)%>.mimeType');
                $originalName = $request->input('<%-to.snake(field)%>.originalName');
                $filename = uniqid() . '-' . $originalName;
                $path = 'uploads/' . date('Y/m/d') . '/' . $filename;
                $stored = Storage::disk('private')->put($path, $fileData);
                if($stored) {
                    $data['<%-to.snake(field)%>_path'] = $path;
                    $data['<%-to.snake(field)%>_type'] = $mimeType;
                    $data['<%-to.snake(field)%>_name'] = $originalName;
                }
            }
<%      });-%>
<%  }-%>

            $<%- entityName %>->update($data);
<%  if(!isEmpty(fileFields)) {-%>

            foreach ($filesToDeletePaths as $filePath) {
                if ($filePath && Storage::disk('private')->exists($filePath)) {
                    Storage::disk('private')->delete($filePath);
                }
            }
<%  }-%>
<%          if (createRelated) { -%>
<%- createRelated.split("\n").map(line => line.replace(/ \/\/ only-update$/,'')).join("\n") %>
<%          } -%>
            return response()->json($<%- entityName %>, 200);
        } catch (\Exception $e) {
            return $this->handleUpdateError($e);
        }
    }

    public function destroy($id)
    {
        try {
            $<%- entityName %> = <%- className %>::findOrFail($id);
            $<%- entityName %>->delete();
<%  fileFields.forEach((field) => {-%>
            if ($<%- entityName %>-><%-to.snake(field)%>_path) {
                Storage::disk('private')->delete($<%- entityName %>-><%-to.snake(field)%>_path);
            }
<%  });-%>
            return response(null, 200);
        } catch (\Exception $e) {
            return $this->handleDeleteError($e);
        }
    }
}