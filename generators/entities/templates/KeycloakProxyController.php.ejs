<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\URL;
use Illuminate\Support\Str;

class KeycloakProxyController extends Controller
{
    protected $keycloakBaseUrl;
    protected $realm;
    protected $clientId;
    protected $clientSecret;

    public function __construct()
    {
        $this->keycloakBaseUrl = env('KEYCLOAK_BASE_URL');
        $this->realm = env('KEYCLOAK_REALM');
        $this->clientId = env('KEYCLOAK_CLIENT_ID');
        $this->clientSecret = env('KEYCLOAK_CLIENT_SECRET');
    }

    /**
     * Starts the login flow with Authorization Code
     */
    public function initiateLogin(Request $request)
    {
        // Generate PKCE data
        $codeVerifier = Str::random(64);
        $codeChallenge = rtrim(strtr(base64_encode(hash('sha256', $codeVerifier, true)), '+/', '-_'), '=');
        $state = Str::random(32);

        // 1. Save in the session (primary system)
        $request->session()->put('code_verifier', $codeVerifier);
        $request->session()->put('auth_state', $state);
        $request->session()->save(); // Attempt to save immediately

        // 2. Also save in the cache as backup/synchronization
        Cache::put('auth_state_' . $state, $codeVerifier, 300); // 5 minutes

        // Build the URL
        $redirectUri = URL::to('/api/auth/callback');
        $authUrl = "{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/auth";
        $queryParams = http_build_query([
            'client_id' => $this->clientId,
            'redirect_uri' => $redirectUri,
            'response_type' => 'code',
            'scope' => 'openid profile email',
            'state' => $state,
            'code_challenge' => $codeChallenge,
            'code_challenge_method' => 'S256',
        ]);

        return response()->json([
            'authUrl' => "{$authUrl}?{$queryParams}"
        ]);
    }

    public function handleCallback(Request $request)
    {
        $state = $request->input('state');
        $code = $request->input('code');

        if (!$state || !$code) {
            return response()->json(['message' => 'Missing required parameters'], 400);
        }

        // Strategy 1: First try to retrieve from the session (primary system)
        $sessionState = $request->session()->get('auth_state');
        $codeVerifier = null;

        // If the state matches, use the code_verifier from the session
        if ($sessionState === $state) {
            $codeVerifier = $request->session()->get('code_verifier');
            $source = 'session';
        }

        // Strategy 2: If not found in the session, try the cache
        if (!$codeVerifier) {
            $codeVerifier = Cache::get('auth_state_' . $state);

            if ($codeVerifier) {
                $source = 'cache';

                // Optional: also synchronize the session if desired
                $request->session()->put('code_verifier', $codeVerifier);
                $request->session()->put('auth_state', $state);
            }
        }

        // If we still haven't found a valid code_verifier, fail
        if (!$codeVerifier) {
            \Log::warning('Authentication data not found', [
                'state' => $state,
                'session_state' => $sessionState,
                'session_id' => $request->session()->getId()
            ]);

            return response()->json(['message' => 'Invalid state parameter'], 400);
        }

        // Log for debugging
        \Log::info('Auth data recovered', [
            'source' => $source,
            'state' => $state
        ]);

        // Exchange the code for tokens
        try {
            $redirectUri = URL::to('/api/auth/callback');

            $response = Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/token", [
                'client_id' => $this->clientId,
                'client_secret' => $this->clientSecret,
                'grant_type' => 'authorization_code',
                'code' => $code,
                'redirect_uri' => $redirectUri,
                'code_verifier' => $codeVerifier
            ]);

            if ($response->successful()) {
                // Cleanup
                $request->session()->forget(['code_verifier', 'auth_state']);
                Cache::forget('auth_state_' . $state);

                $tokens = $response->json();
                $request->session()->put('auth_tokens', $tokens);

                return redirect(env('FRONTEND_URL', '/') . '?auth_success=true');
            }

            return response()->json([
                'message' => 'Failed to exchange code for tokens',
                'details' => $response->json()
            ], 400);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Token exchange error',
                'details' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Checks if the user already has an active session with Keycloak
     * This endpoint can be used for session checks without re-authentication
     */
    public function checkSession(Request $request)
    {
        try {
            // Retrieve tokens from the server-side session if present
            $tokens = $request->session()->get('auth_tokens');

            if ($tokens && isset($tokens['access_token'])) {
                // Verify that the token is valid
                $userInfoResponse = Http::withHeaders([
                    'Authorization' => "Bearer {$tokens['access_token']}"
                ])->get("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/userinfo");

                if ($userInfoResponse->successful()) {
                    return response()->json([
                        'isAuthenticated' => true,
                        'tokens' => $tokens,
                        'user' => $userInfoResponse->json()
                    ]);
                }

                // Invalid token, try refreshing it
                if (isset($tokens['refresh_token'])) {
                    $refreshResponse = Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/token", [
                        'client_id' => $this->clientId,
                        'client_secret' => $this->clientSecret,
                        'grant_type' => 'refresh_token',
                        'refresh_token' => $tokens['refresh_token']
                    ]);

                    if ($refreshResponse->successful()) {
                        $newTokens = $refreshResponse->json();
                        $request->session()->put('auth_tokens', $newTokens);

                        return response()->json([
                            'isAuthenticated' => true,
                            'tokens' => $newTokens
                        ]);
                    }
                }
            }

            // If we reach here, there is no valid session
            return response()->json([
                'isAuthenticated' => false
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'isAuthenticated' => false,
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Refreshes the token using the refresh token
     */
    public function refreshToken(Request $request)
    {
        $refreshToken = $request->input('refresh_token');

        if (!$refreshToken) {
            // Try to retrieve the refresh token from the session
            $tokens = $request->session()->get('auth_tokens');
            $refreshToken = $tokens['refresh_token'] ?? null;

            if (!$refreshToken) {
                return response()->json(['message' => 'Refresh token not provided'], 400);
            }
        }

        try {
            $response = Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/token", [
                'client_id' => $this->clientId,
                'client_secret' => $this->clientSecret,
                'grant_type' => 'refresh_token',
                'refresh_token' => $refreshToken,
            ]);

            if ($response->successful()) {
                $newTokens = $response->json();
                // Update tokens in the session
                $request->session()->put('auth_tokens', $newTokens);
                return response()->json($newTokens);
            }

            return response()->json([
                'message' => 'Token refresh failed',
                'details' => $response->json()
            ], 401);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Token refresh service error',
                'details' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Verifies the token
     */
    public function verifyToken(Request $request)
    {
        $token = $request->bearerToken();

        if (!$token) {
            // Try to retrieve the token from the session
            $tokens = $request->session()->get('auth_tokens');
            $token = $tokens['access_token'] ?? null;

            if (!$token) {
                return response()->json(['message' => 'Token not provided'], 401);
            }
        }

        try {
            $response = Http::withHeaders([
                'Authorization' => 'Bearer ' . $token
            ])->get("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/userinfo");

            if ($response->successful()) {
                return response()->json($response->json());
            }

            return response()->json(['message' => 'Invalid token'], 401);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Token validation error',
                'details' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Logout
     */
    public function logout(Request $request)
    {
        $refreshToken = $request->input('refresh_token');

        if (!$refreshToken) {
            // Try to retrieve the refresh token from the session
            $tokens = $request->session()->get('auth_tokens');
            $refreshToken = $tokens['refresh_token'] ?? null;
        }

        // If there is a refresh token, revoke it
        if ($refreshToken) {
            try {
                Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/logout", [
                    'client_id' => $this->clientId,
                    'client_secret' => $this->clientSecret,
                    'refresh_token' => $refreshToken,
                ]);
            } catch (\Exception $e) {
                // Continue even if logout fails
            }
        }

        // Build the logout URL for SSO
        $redirect = env('FRONTEND_URL', '/');
        $logoutUrl = "{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/logout?redirect_uri=" . urlencode($redirect);

        // Clear the session
        $request->session()->forget('auth_tokens');

        return response()->json([
            'message' => 'Logged out successfully',
            'logoutUrl' => $logoutUrl  // URL for SSO logout
        ]);
    }
}