<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\URL;
use Illuminate\Support\Str;

class KeycloakProxyController extends Controller
{
    protected $keycloakBaseUrl;
    protected $realm;
    protected $clientId;
    protected $clientSecret;
    protected $frontendUrl;

    public function __construct()
    {
        $this->keycloakBaseUrl = env('KEYCLOAK_BASE_URL');
        $this->realm = env('KEYCLOAK_REALM');
        $this->clientId = env('KEYCLOAK_CLIENT_ID');
        $this->clientSecret = env('KEYCLOAK_CLIENT_SECRET');
        $this->frontendUrl = env('FRONTEND_URL');
    }

    /**
     * Inizia il flusso di login con Authorization Code
     */
    public function initiateLogin(Request $request)
    {
        // Genera un PKCE code verifier e code challenge
        $codeVerifier = Str::random(64);
        $codeChallenge = rtrim(strtr(base64_encode(hash('sha256', $codeVerifier, true)), '+/', '-_'), '=');

        // Genera un state per prevenire CSRF
        $state = Str::random(32);

        // Salva code verifier e state in sessione
        $request->session()->put('code_verifier', $codeVerifier);
        $request->session()->put('auth_state', $state);

        // URL di callback per il ritorno da Keycloak
        $redirectUri = $this->frontendUrl . '/api/auth/callback';

        // Costruisci l'URL di autorizzazione di Keycloak
        $authUrl = "{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/auth";
        $queryParams = http_build_query([
            'client_id' => $this->clientId,
            'redirect_uri' => $redirectUri,
            'response_type' => 'code',
            'scope' => 'openid profile email',
            'state' => $state,
            'code_challenge' => $codeChallenge,
            'code_challenge_method' => 'S256',
        ]);

        // Restituisci l'URL di autorizzazione al frontend
        return response()->json([
            'authUrl' => "{$authUrl}?{$queryParams}"
        ]);
    }

    /**
     * Callback che riceve il codice da Keycloak e lo scambia con token
     */
    public function handleCallback(Request $request)
    {
        $code = $request->input('code');
        $state = $request->input('state');
        $sessionState = $request->session()->get('auth_state');

        // Verifica lo state per prevenire CSRF
        if (!$state || $state !== $sessionState) {
            return response()->json([
                'message' => 'Invalid state parameter'
            ], 400);
        }

        $codeVerifier = $request->session()->get('code_verifier');
        if (!$codeVerifier) {
            return response()->json([
                'message' => 'Code verifier not found'
            ], 400);
        }

        // Exchange the code for tokens
        try {
            $redirectUri = $this->frontendUrl . '/api/auth/callback';

            $response = Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/token", [
                'client_id' => $this->clientId,
                'client_secret' => $this->clientSecret,
                'grant_type' => 'authorization_code',
                'code' => $code,
                'redirect_uri' => $redirectUri,
                'code_verifier' => $codeVerifier
            ]);

            if ($response->successful()) {
                // Cleanup
                $request->session()->forget(['code_verifier', 'auth_state']);

                $tokens = $response->json();

                $request->session()->put('auth_tokens', $tokens);

                return redirect($this->frontendUrl . '?auth_success=true');
            }

            return response()->json([
                'message' => 'Failed to exchange code for tokens',
                'details' => $response->json()
            ], 400);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Token exchange error',
                'details' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Checks if the user already has an active session with Keycloak
     * This endpoint can be used for session checks without re-authentication
     */
    public function checkSession(Request $request)
    {
        try {
            // Retrieve tokens from the server-side session if present
            $tokens = $request->session()->get('auth_tokens');

            if ($tokens && isset($tokens['access_token'])) {
                // Verify that the token is valid
                $userInfoResponse = Http::withHeaders([
                    'Authorization' => "Bearer {$tokens['access_token']}"
                ])->get("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/userinfo");

                if ($userInfoResponse->successful()) {
                    return response()->json([
                        'isAuthenticated' => true,
                        'tokens' => $tokens,
                        'user' => $userInfoResponse->json()
                    ]);
                }

                // Invalid token, try refreshing it
                if (isset($tokens['refresh_token'])) {
                    $refreshResponse = Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/token", [
                        'client_id' => $this->clientId,
                        'client_secret' => $this->clientSecret,
                        'grant_type' => 'refresh_token',
                        'refresh_token' => $tokens['refresh_token']
                    ]);

                    if ($refreshResponse->successful()) {
                        $newTokens = $refreshResponse->json();
                        $request->session()->put('auth_tokens', $newTokens);

                        return response()->json([
                            'isAuthenticated' => true,
                            'tokens' => $newTokens
                        ]);
                    }
                }
            }

            // If we reach here, there is no valid session
            return response()->json([
                'isAuthenticated' => false
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'isAuthenticated' => false,
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Refreshes the token using the refresh token
     */
    public function refreshToken(Request $request)
    {
        $refreshToken = $request->input('refresh_token');

        if (!$refreshToken) {
            // Try to retrieve the refresh token from the session
            $tokens = $request->session()->get('auth_tokens');
            $refreshToken = $tokens['refresh_token'] ?? null;

            if (!$refreshToken) {
                return response()->json(['message' => 'Refresh token not provided'], 400);
            }
        }

        try {
            $response = Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/token", [
                'client_id' => $this->clientId,
                'client_secret' => $this->clientSecret,
                'grant_type' => 'refresh_token',
                'refresh_token' => $refreshToken,
            ]);

            if ($response->successful()) {
                $newTokens = $response->json();
                // Update tokens in the session
                $request->session()->put('auth_tokens', $newTokens);
                return response()->json($newTokens);
            }

            return response()->json([
                'message' => 'Token refresh failed',
                'details' => $response->json()
            ], 401);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Token refresh service error',
                'details' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Verifies the token
     */
    public function verifyToken(Request $request)
    {
        $token = $request->bearerToken();

        if (!$token) {
            // Try to retrieve the token from the session
            $tokens = $request->session()->get('auth_tokens');
            $token = $tokens['access_token'] ?? null;

            if (!$token) {
                return response()->json(['message' => 'Token not provided'], 401);
            }
        }

        try {
            $response = Http::withHeaders([
                'Authorization' => 'Bearer ' . $token
            ])->get("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/userinfo");

            if ($response->successful()) {
                return response()->json($response->json());
            }

            return response()->json(['message' => 'Invalid token'], 401);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Token validation error',
                'details' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Logout
     */
    public function logout(Request $request)
    {
        $refreshToken = $request->input('refresh_token');

        if (!$refreshToken) {
            // Try to retrieve the refresh token from the session
            $tokens = $request->session()->get('auth_tokens');
            $refreshToken = $tokens['refresh_token'] ?? null;
        }

        // If there is a refresh token, revoke it
        if ($refreshToken) {
            try {
                Http::asForm()->post("{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/logout", [
                    'client_id' => $this->clientId,
                    'client_secret' => $this->clientSecret,
                    'refresh_token' => $refreshToken,
                ]);
            } catch (\Exception $e) {
                // Continue even if logout fails
            }
        }

        // Build the logout URL for SSO
        $logoutUrl = "{$this->keycloakBaseUrl}/realms/{$this->realm}/protocol/openid-connect/logout?redirect_uri=" . urlencode($this->frontendUrl);

        // Clear the session
        $request->session()->forget('auth_tokens');

        return response()->json([
            'message' => 'Logged out successfully',
            'logoutUrl' => $logoutUrl  // URL for SSO logout
        ]);
    }
}