<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\File;
<% entities.forEach(function(entity) { -%>
use App\Models\<%= entity.name %>;
<% }); -%>
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        $this->withoutScout(function () {
<% entities.forEach(function(entity) { -%>
            $this->seedModel(<%= entity.name %>::class, '<%= entity.name %>.csv', <%= n %>);
<% }); -%>

            // Many-to-many relationships
<% manyToMany.forEach(function(rel) { -%>
            $this->seedManyToMany(<%= rel.fromEntity %>::class, '<%= rel.relPropery %>', <%= rel.toEntity %>::class, '<%= rel.fromEntity %>_<%= rel.toEntity %>.csv', <%- Math.round(n/2) %>);
<% }); -%>
        });
        $this->indexModels();
    }

    /**
     * Seed without synchronizing with Scout
     */
    private function withoutScout(callable $callback): void
    {
        $originalDriver = config('scout.driver');
        config(['scout.driver' => null]);
        try {
            $callback();
        } finally {
            config(['scout.driver' => $originalDriver]);
        }
    }

    /**
     * Index all searchable models
     */
    private function indexModels(): void
    {
        $searchableModels = [
<% entities.forEach(function(entity) { -%>
            <%= entity.name %>::class,
<% }); -%>
        ];

        $this->command->newLine();
        $this->command->info('ðŸ” Indexing all searchable models...');

        foreach ($searchableModels as $model) {
            $modelName = class_basename($model);
            $this->command->info("  â†’ Indexing {$modelName}...");

            try {
                \Artisan::call('scout:import', ['model' => $model]);
                $count = $model::count();
                $this->command->info("    âœ“ {$count} records indexed");
            } catch (\Exception $e) {
                $this->command->error("    âœ— Failed: {$e->getMessage()}");
            }
        }

        $this->command->newLine();
        $this->command->info('âœ“ Seeding and indexing completed!');
    }

    /**
     * Seed from CSV or factory
     */
    private function seedModel(string $modelClass, string $csvFilename, int $minCount): void
    {
        $csvPath = database_path("seeders/csv/{$csvFilename}");

        if (File::exists($csvPath)) {
            // If CSV exists, load ONLY from CSV
            $this->seedFromCsv($modelClass, $csvPath);
        } else {
            // Otherwise, use ONLY the factory
            while ($modelClass::count() < $minCount) {
                $modelClass::factory()->create();
            }
        }
    }

    /**
     * Load data from a CSV file
     * 
     * @param string $modelClass Fully qualified name of the model class
     * @param string $csvPath Full path to the CSV file
     * @return int Number of records loaded
     */
    private function seedFromCsv(string $modelClass, string $csvPath): void
    {
        $csv = array_map('str_getcsv', file($csvPath));
        $headers = array_shift($csv);

        foreach ($csv as $row) {
            // Skip empty rows
            if (empty(array_filter($row))) {
                continue;
            }
            
            $data = array_combine($headers, $row);
            
            // Remove empty or null fields
            $data = array_filter($data, function($value) {
                return $value !== '' && $value !== null;
            });

            try {
                $modelClass::create($data);
            } catch (\Throwable $th) {
                $this->command->error("Failed to create {$modelClass}. Error: " . $th->getMessage());
            }
        }
    }

    /**
     * Seed many-to-many relationships
     */
    private function seedManyToMany(
        string $modelClass, 
        string $relationName, 
        string $relatedClass, 
        string $csvFilename, 
        int $randomCount
    ): void {
        $csvPath = database_path("seeders/csv/{$csvFilename}");

        if (File::exists($csvPath)) {
            $this->seedManyToManyFromCsv($modelClass, $relationName, $csvPath);
        } else {
            // Use random associations
            $modelClass::all()->each(function ($entity) use ($relationName, $relatedClass, $randomCount) {
                $entity->$relationName()->attach(
                    $relatedClass::all()->random($randomCount)->pluck('id')->toArray()
                );
            });
        }
    }

    /**
     * Load many-to-many relationships from a CSV file.
     * The CSV must have the columns: model_id, related_id.
     */
    private function seedManyToManyFromCsv(string $modelClass, string $relationName, string $csvPath): void
    {
        $csv = array_map('str_getcsv', file($csvPath));
        $headers = array_shift($csv);

        $grouped = [];
        foreach ($csv as $row) {
            // Salta righe vuote
            if (empty(array_filter($row))) {
                continue;
            }
            
            $data = array_combine($headers, $row);
            $modelId = $data['model_id'];
            $relatedId = $data['related_id'];
            
            if (!isset($grouped[$modelId])) {
                $grouped[$modelId] = [];
            }
            $grouped[$modelId][] = $relatedId;
        }

        foreach ($grouped as $modelId => $relatedIds) {
            $model = $modelClass::find($modelId);
            if ($model) {
                $model->$relationName()->attach($relatedIds);
            }
        }
    }
}