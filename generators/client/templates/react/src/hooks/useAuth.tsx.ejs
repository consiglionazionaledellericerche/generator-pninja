import { useState, useCallback, useEffect } from 'react';
import { tokenStorage } from '../utils/tokenStore';
import { AuthState, AuthTokens, User } from '../types/auth';

export const useAuth = () => {
  const initialTokens = tokenStorage.getTokens();

  const [authState, setAuthState] = useState<AuthState>({
    isAuthenticated: !!initialTokens?.access_token,
    tokens: initialTokens,
    user: null,
    loading: true,
    error: null,
  });

  // Funzione per refreshare i token
  const refreshTokens = useCallback(async (): Promise<AuthTokens> => {
    const tokens = tokenStorage.getTokens();

    if (!tokens?.refresh_token) {
      console.error('Nessun refresh token disponibile');
      throw new Error('Nessun refresh token disponibile');
    }

    try {
      console.log('Tentativo di refresh token...');

      // Prima ottieni il token CSRF
      let csrfToken = '';
      try {
        const csrfResponse = await fetch('/api/csrf-token', {
          credentials: 'include',
        });
        if (csrfResponse.ok) {
          const csrfData = await csrfResponse.json();
          csrfToken = csrfData.csrf_token;
        }
      } catch (csrfError) {
        console.warn('Errore nel recuperare il token CSRF:', csrfError);
      }

      // Aggiungi un timeout lungo per evitare fallimenti prematuri
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 secondi di timeout

      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };

      // Aggiungi il token CSRF all'header se disponibile
      if (csrfToken) {
        headers['X-CSRF-TOKEN'] = csrfToken;
      }

      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers,
        body: JSON.stringify({
          refresh_token: tokens.refresh_token,
        }),
        credentials: 'include',
        signal: controller.signal,
      }).finally(() => clearTimeout(timeoutId));

      if (response.ok) {
        const newTokens = await response.json();
        console.log('Refresh token riuscito, nuovi token ottenuti');

        // Salva i nuovi token con timestamp
        tokenStorage.setTokens(newTokens);

        // Aggiorna lo stato con i nuovi token
        setAuthState((prev) => ({
          ...prev,
          isAuthenticated: true,
          tokens: newTokens,
          error: null,
          loading: false,
        }));

        return newTokens as AuthTokens;
      } else {
        // Leggi il corpo dell'errore
        const errorText = await response.text();
        console.error('Refresh token fallito:', response.status, errorText);

        // In caso di 401/403 (token non valido), cancella tutto
        if (response.status === 401 || response.status === 403) {
          tokenStorage.clearTokens();
          setAuthState({
            isAuthenticated: false,
            tokens: null,
            user: null,
            loading: false,
            error: 'Sessione scaduta',
          });
          throw new Error('Refresh token fallito: token non valido');
        }

        // Per errori CSRF 419, mostra un messaggio specifico
        if (response.status === 419) {
          throw new Error('Errore CSRF: Token di sicurezza scaduto. Ricarica la pagina e riprova.');
        }

        // Per altri errori (es. 500, 502), potrebbe essere un problema temporaneo del server
        throw new Error(`Refresh token fallito: ${response.status} ${errorText}`);
      }
    } catch (error) {
      // Verifica se è un errore di timeout/network o altro
      if (error instanceof DOMException && error.name === 'AbortError') {
        console.error('Timeout durante il refresh del token');
        throw new Error('Timeout durante il refresh del token');
      }

      // Per gli errori di rete, non cancelliamo i token automaticamente
      if (error instanceof TypeError && error.message.includes('network')) {
        console.error('Errore di rete durante il refresh:', error);
        throw error;
      }

      // Per altri errori
      console.error('Errore durante il refresh token:', error);
      throw error;
    }
  }, []);

  // Controlla la sessione all'avvio
  useEffect(() => {
    const checkSession = async () => {
      try {
        // Verifica se c'è una query parameter auth_success nell'URL
        const urlParams = new URLSearchParams(window.location.search);
        const authSuccess = urlParams.get('auth_success');

        if (authSuccess === 'true') {
          // Rimuovi il parametro dalla URL senza refreshare la pagina
          const newUrl =
            window.location.pathname +
            (window.location.search
              ? window.location.search.replace(/auth_success=true&?/, '')
              : '') +
            window.location.hash;
          window.history.replaceState({}, document.title, newUrl);
        }

        // Controlla se c'è già una sessione autenticata
        const response = await fetch('/api/auth/check-session', {
          credentials: 'include', // Importante per inviare i cookie di sessione
        });

        if (response.ok) {
          const data = await response.json();

          if (data.isAuthenticated && data.tokens) {
            console.log('Sessione trovata, utente già autenticato');

            // Salva i token
            tokenStorage.setTokens(data.tokens);

            setAuthState({
              isAuthenticated: true,
              tokens: data.tokens,
              user: data.user as User,
              loading: false,
              error: null,
            });

            return;
          }
        }

        // Controlla se abbiamo token in localStorage
        const tokens = tokenStorage.getTokens();

        if (tokens?.access_token) {
          try {
            // Verifica il token
            const userResponse = await fetch('/api/auth/verify', {
              headers: {
                Authorization: `Bearer ${tokens.access_token}`,
              },
              credentials: 'include',
            });

            if (userResponse.ok) {
              const userData = await userResponse.json();

              setAuthState({
                isAuthenticated: true,
                tokens,
                user: userData,
                loading: false,
                error: null,
              });

              return;
            }

            // Token invalido, prova a refreshare
            if (tokens.refresh_token) {
              try {
                await refreshTokens();
                return;
              } catch (refreshError) {
                console.error('Refresh fallito:', refreshError);
                tokenStorage.clearTokens();
              }
            }
          } catch (error) {
            console.error('Errore di verifica token:', error);
            tokenStorage.clearTokens();
          }
        }

        // Se arriviamo qui, non c'è una sessione valida
        setAuthState({
          isAuthenticated: false,
          tokens: null,
          user: null,
          loading: false,
          error: null,
        });
      } catch (error) {
        console.error('Errore nel controllo della sessione:', error);
        setAuthState({
          isAuthenticated: false,
          tokens: null,
          user: null,
          loading: false,
          error: 'Errore nel controllo della sessione',
        });
      }
    };

    checkSession();
  }, [refreshTokens]);

  // Inizia il flusso di login usando il flusso Authorization Code (SSO)
  const login = useCallback(async () => {
    try {
      const response = await fetch('/api/auth/initiate-login', {
        credentials: 'include',
      });

      if (!response.ok) {
        throw new Error("Errore nell'inizializzazione del login");
      }

      const data = await response.json();
      window.location.href = data.authUrl;

      return { success: true };
    } catch (error) {
      console.error("Errore nell'avvio del login:", error);

      setAuthState((prev) => ({
        ...prev,
        loading: false,
        error: "Errore nell'avvio del login",
      }));

      return {
        success: false,
        error: "Errore nell'avvio del login",
      };
    }
  }, []);

  // Logout
  const logout = useCallback(async () => {
    const tokens = tokenStorage.getTokens();

    try {
      console.log('Logout in corso...');

      // Prima ottieni il token CSRF
      let csrfToken = '';
      try {
        const csrfResponse = await fetch('/api/csrf-token', {
          credentials: 'include',
        });
        if (csrfResponse.ok) {
          const csrfData = await csrfResponse.json();
          csrfToken = csrfData.csrf_token;
        }
      } catch (csrfError) {
        console.warn('Errore nel recuperare il token CSRF:', csrfError);
      }

      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };

      // Aggiungi il token CSRF all'header se disponibile
      if (csrfToken) {
        headers['X-CSRF-TOKEN'] = csrfToken;
      }

      const response = await fetch('/api/auth/logout', {
        method: 'POST',
        headers,
        body: JSON.stringify({
          refresh_token: tokens?.refresh_token,
        }),
        credentials: 'include', // Importante per i cookie di sessione
      });

      // Cancella i token in localStorage
      tokenStorage.clearTokens();

      // Aggiorna lo stato
      setAuthState({
        isAuthenticated: false,
        tokens: null,
        user: null,
        loading: false,
        error: null,
      });

      if (response.ok) {
        const data = await response.json();

        // Se abbiamo un URL di logout per SSO, reindirizza
        if (data.logoutUrl) {
          window.location.href = data.logoutUrl;
        }
      }
    } catch (error) {
      console.error('Errore nel logout:', error);

      // Anche in caso di errore, cancella i token e aggiorna lo stato
      tokenStorage.clearTokens();
      setAuthState({
        isAuthenticated: false,
        tokens: null,
        user: null,
        loading: false,
        error: null,
      });
    }
  }, []);

  // Esportazione delle funzionalità di autenticazione
  return {
    isAuthenticated: authState.isAuthenticated,
    user: authState.user as User,
    loading: authState.loading,
    error: authState.error,
    login,
    logout,
    refreshTokens,
  };
};
