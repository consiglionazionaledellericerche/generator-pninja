import { AuthTokens, UserRoles } from '../types/auth'; // import centralized types

// Interface for the decoded JWT payload
export interface DecodedJwtPayload {
  // Standard JWT claims
  exp?: number; // Expiration time
  iat?: number; // Issued at
  sub?: string; // Subject
  iss?: string; // Issuer
  aud?: string | string[]; // Audience

  // Keycloak specific claims
  realm_access?: { roles: string[] };
  resource_access?: Record<string, { roles: string[] }>;

  // For any other properties
  [key: string]: unknown;
}

// Function to decode a JWT token
export const decodeJwt = (token: string): DecodedJwtPayload | null => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      window
        .atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('Error decoding the JWT token:', error);
    return null;
  }
};

// Function to extract roles from a JWT token
export const extractRolesFromToken = (token: string): UserRoles => {
  const decodedToken = decodeJwt(token);
  const defaultRoles: UserRoles = {
    realmRoles: [],
    clientRoles: {},
    allRoles: [],
  };

  if (!decodedToken) return defaultRoles;

  // Extract realm roles
  const realmRoles = decodedToken.realm_access?.roles || [];

  // Extract client roles
  const clientRoles: Record<string, string[]> = {};
  if (decodedToken.resource_access) {
    Object.keys(decodedToken.resource_access).forEach((clientId) => {
      if (decodedToken.resource_access?.[clientId]?.roles) {
        clientRoles[clientId] = decodedToken.resource_access[clientId].roles;
      }
    });
  }

  // Create a unified list of all roles
  const allRoles = [...realmRoles, ...Object.values(clientRoles).flat()];

  return {
    realmRoles,
    clientRoles,
    allRoles,
  };
};

// Check if a token is about to expire
export const isTokenExpiringSoon = (token: string, bufferSeconds = 60): boolean => {
  try {
    const decodedToken = decodeJwt(token);
    if (decodedToken && decodedToken.exp) {
      // exp is in seconds since epoch, while Date.now() is in milliseconds
      const expTimestamp = (decodedToken.exp as number) * 1000;
      // Refresh if the token expires within the buffer time
      return expTimestamp - Date.now() < bufferSeconds * 1000;
    }

    // If we can't determine the expiration, consider it expiring
    return true;
  } catch (error) {
    console.warn('Error checking token expiration:', error);
    return true;
  }
};

// Token storage handler
export const tokenStorage = {
  setTokens: (tokens: AuthTokens) => {
    try {
      // Save the tokens
      localStorage.setItem('auth_tokens', JSON.stringify(tokens));

      // Save the timestamp of receipt
      localStorage.setItem('token_received_time', Date.now().toString());

      console.info('Tokens successfully saved:', new Date().toISOString());
    } catch (error) {
      console.error('Error saving tokens:', error);
    }
  },

  getTokens: (): AuthTokens | null => {
    try {
      const tokens = localStorage.getItem('auth_tokens');
      if (!tokens) return null;

      return JSON.parse(tokens);
    } catch (error) {
      console.error('Error retrieving tokens:', error);
      return null;
    }
  },

  clearTokens: () => {
    try {
      localStorage.removeItem('auth_tokens');
      localStorage.removeItem('token_received_time');
    } catch (error) {
      console.error('Error clearing tokens:', error);
    }
  },

  // Get roles from the currently stored token
  getRoles: (): UserRoles | null => {
    const tokens = tokenStorage.getTokens();
    if (!tokens?.access_token) return null;

    return extractRolesFromToken(tokens.access_token);
  },
};
