import { AuthTokens, UserRoles } from '../types/auth'; // import centralized types

// Interface for the decoded JWT payload
export interface DecodedJwtPayload {
  // Standard JWT claims
  exp?: number; // Expiration time
  iat?: number; // Issued at
  sub?: string; // Subject
  iss?: string; // Issuer
  aud?: string | string[]; // Audience

  // Keycloak specific claims
  realm_access?: { roles: string[] };
  resource_access?: Record<string, { roles: string[] }>;

  // For any other properties
  [key: string]: unknown;
}

// Function to decode a JWT token
export const decodeJwt = (token: string): DecodedJwtPayload | null => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      window
        .atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('Error decoding the JWT token:', error);
    return null;
  }
};

// Function to extract roles from a JWT token
export const extractRolesFromToken = (token: string): UserRoles => {
  const decodedToken = decodeJwt(token);
  const defaultRoles: UserRoles = {
    realmRoles: [],
    clientRoles: {},
    allRoles: [],
  };

  if (!decodedToken) return defaultRoles;

  // Extract realm roles
  const realmRoles = decodedToken.realm_access?.roles || [];

  // Extract client roles
  const clientRoles: Record<string, string[]> = {};
  if (decodedToken.resource_access) {
    Object.keys(decodedToken.resource_access).forEach((clientId) => {
      if (decodedToken.resource_access?.[clientId]?.roles) {
        clientRoles[clientId] = decodedToken.resource_access[clientId].roles;
      }
    });
  }

  // Create a unified list of all roles
  const allRoles = [...realmRoles, ...Object.values(clientRoles).flat()];

  return {
    realmRoles,
    clientRoles,
    allRoles,
  };
};

// Check if a token is about to expire
export const isTokenExpiringSoon = (token: string, bufferSeconds = 60): boolean => {
  try {
    const decodedToken = decodeJwt(token);
    if (decodedToken && decodedToken.exp) {
      // exp is in seconds since epoch, while Date.now() is in milliseconds
      const expTimestamp = (decodedToken.exp as number) * 1000;
      // Refresh if the token expires within the buffer time
      return expTimestamp - Date.now() < bufferSeconds * 1000;
    }

    // If we can't determine the expiration, consider it expiring
    return true;
  } catch (error) {
    console.warn('Error checking token expiration:', error);
    return true;
  }
};

// Token storage handler
class MemoryTokenStorage {
  private tokens: AuthTokens | null = null;

  setTokens(tokens: AuthTokens): void {
    this.tokens = tokens;
    console.info('Tokens successfully saved in memory');
  }

  getTokens(): AuthTokens | null {
    return this.tokens;
  }

  clearTokens(): void {
    this.tokens = null;
    console.info('Tokens cleared from memory');
  }

  // Get roles from the currently stored token
  getRoles(): UserRoles | null {
    if (!this.tokens?.access_token) return null;
    return extractRolesFromToken(this.tokens.access_token);
  }
}

export const tokenStorage = new MemoryTokenStorage();
