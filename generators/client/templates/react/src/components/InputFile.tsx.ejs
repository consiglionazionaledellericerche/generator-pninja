import { useTranslation } from 'react-i18next';
import prettyBytes from 'pretty-bytes';
import { FileIcon, FileImageIcon, EditIcon, Trash2Icon, Undo2Icon, InfoIcon } from 'lucide-react';
import { useState, useRef } from 'react';

import { UseFormRegister, FieldErrors, UseFormTrigger, UseFormSetValue } from 'react-hook-form';

type TransformedFileData = {
  data: string;
  mimeType: string;
  originalName: string;
  size: number;
  delete: boolean;
};

const inputClassName = (hasErrors = false) =>
  `scheme-light dark:scheme-dark outline-0${hasErrors ? ' outline-2 -outline-offset-2 outline-red-500' : ''} focus:outline-2 focus:-outline-offset-2 ${hasErrors ? 'focus:outline-red-500' : 'focus:outline-blue-600'} rounded-md block w-full mt-3 border-none bg-slate-200 text-slate-900 dark:bg-gray-800 dark:text-gray-300 text-sm/6 py-1.5 px-3`;

interface InputFileProps {
  accept?: string;
  entity?: unknown;
  errors?: FieldErrors<Record<string, unknown>>;
  fieldName: string;
  register: UseFormRegister<Record<string, unknown>>;
  setValue: UseFormSetValue<Record<string, unknown>>;
  trigger: UseFormTrigger<Record<string, unknown>>;
  validations?: {
    required?: boolean;
    minbytes?: number;
    maxbytes?: number;
  };
}

function fileToBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result;
      if (typeof result !== 'string') {
        reject(new Error('Failed to read file as data URL'));
        return;
      }
      // Removes "data:mime/type;base64," and keeps only the base64
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = () => reject(new Error('Error reading file'));
    reader.readAsDataURL(file);
  });
}

const InputFile: React.FC<InputFileProps> = ({
  accept,
  entity,
  errors,
  fieldName,
  register,
  setValue,
  trigger,
  validations,
}) => {
  const { t } = useTranslation();
  const entityData = entity as Record<string, unknown>;
  const hasFile = entityData?.[`${fieldName}_path`] || false;
  const [shouldShowInput, setShouldShowInput] = useState(!hasFile);
  const [isMarkedForDeletion, setIsMarkedForDeletion] = useState(false);
  const { required, minbytes, maxbytes } = validations || {};
  const inputRef = useRef<HTMLInputElement>(null);

  const markForDeletion = (mark: boolean) => {
    setIsMarkedForDeletion(mark);
    setValue(fieldName, mark ? { delete: true } : null);
    setTimeout(() => {
      trigger(fieldName);
    }, 0);
  };

  const registerProps = register(fieldName, {
    validate: (value: unknown | undefined) => {
      const fileData = value as TransformedFileData | null;

      if (fileData?.mimeType && !fileData.mimeType.startsWith(accept?.replace(/\/\*$/, '') ?? '')) {
        return t('errors.validations.file.invalidType', {
          actual: fileData.mimeType,
          accepted: accept,
        });
      }
      if (typeof fileData?.size === 'number' && minbytes && fileData?.size < minbytes) {
        return t('errors.validations.file.minSize', {
          actual: prettyBytes(fileData?.size),
          min: prettyBytes(minbytes),
        });
      }
      if (typeof fileData?.size === 'number' && maxbytes && fileData?.size > maxbytes) {
        return t('errors.validations.file.maxSize', {
          actual: prettyBytes(fileData?.size),
          max: prettyBytes(maxbytes),
        });
      }
      if (required && (fileData?.delete || (!fileData && !entityData?.[`${fieldName}_path`]))) {
        return t('errors.validations.file.required');
      }
      return true;
    },
  });

  // Handler personalizzato per trasformare e salvare
  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;

    if (!file) {
      setValue(fieldName, null);
      setTimeout(() => {
        trigger(fieldName);
      }, 0);
      return;
    }

    try {
      const fileData = await fileToBase64(file);
      const transformedValue: TransformedFileData = {
        data: fileData,
        mimeType: file.type,
        originalName: file.name,
        size: file.size,
        delete: isMarkedForDeletion,
      };

      setValue(fieldName, transformedValue);
      setTimeout(() => {
        trigger(fieldName);
      }, 0);
    } catch (error) {
      console.error('Error converting file to base64:', error);
      setValue(fieldName, null);
      setTimeout(() => {
        trigger(fieldName);
      }, 0);
    }
  };

  const undoEdit = () => {
    setShouldShowInput(false);
    setValue(fieldName, null);
    // Reset the input value
    const input = document.getElementById(fieldName) as HTMLInputElement;
    if (input) input.value = '';
    setTimeout(() => {
      trigger(fieldName);
    }, 0);
  };

  return (
    <div>
      {hasFile && !shouldShowInput && !isMarkedForDeletion && (
        <div className="mt-3 p-3 bg-slate-100 dark:bg-gray-700 rounded-md">
          <div className="flex items-center justify-between">
            <a
              href={`/api/files/${entityData?.[`${fieldName}_path`]}`}
              className="text-slate-900 dark:text-gray-300 hover:underline flex items-center"
              target="_blank"
              rel="noopener noreferrer"
            >
              {(entityData?.[`${fieldName}_type`] as string)?.startsWith('image/') ? (
                <FileImageIcon className="mr-2 h-4 w-4" />
              ) : (
                <FileIcon className="mr-2 h-4 w-4" />
              )}
              {t('actions.crud.file.viewOrDownload')} {entityData?.[`${fieldName}_name`] as string}
            </a>
            <div className="flex items-center gap-2">
              <button
                type="button"
                onClick={() => setShouldShowInput(true)}
                className="flex items-center text-sm text-slate-900 dark:text-gray-300 cursor-pointer font-medium hover:text-slate-700 hover:dark:text-gray-100"
              >
                <EditIcon className="mr-1 h-4 w-4" />
                {t('actions.crud.edit')}
              </button>
              <button
                type="button"
                onClick={() => markForDeletion(true)}
                className="flex items-center text-sm text-slate-900 dark:text-gray-300 cursor-pointer font-medium hover:text-slate-700 hover:dark:text-gray-100"
              >
                <Trash2Icon className="mr-1 h-4 w-4" />
                {t('actions.crud.delete')}
              </button>
            </div>
          </div>
        </div>
      )}

      {isMarkedForDeletion && (
        <div className="mt-3 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md">
          <div className="flex items-center justify-between">
            <div className="flex items-center text-red-800 dark:text-red-200">
              <Trash2Icon className="mr-2 h-4 w-4" />
              <span className="text-sm font-medium">
                {t('actions.crud.file.markedForDeletion')}
              </span>
            </div>
            <button
              type="button"
              onClick={() => markForDeletion(false)}
              className="flex items-center text-sm text-slate-900 dark:text-gray-300 cursor-pointer font-medium hover:text-slate-700 hover:dark:text-gray-100"
            >
              <Undo2Icon className="mr-2 h-4 w-4" />
              {t('common.undo')}
            </button>
          </div>
        </div>
      )}

      <div className={shouldShowInput && !isMarkedForDeletion ? 'block' : 'hidden'}>
        <div className="mt-3">
          {hasFile && shouldShowInput && (
            <div className="mt-3 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-md">
              <div className="flex items-center justify-between">
                <div className="flex items-center text-yellow-800 dark:text-yellow-200">
                  <InfoIcon className="mr-2 h-4 w-4" />
                  <span className="text-sm font-medium">
                    {t('actions.crud.file.replaceWarning')}
                  </span>
                </div>
                <button
                  type="button"
                  onClick={() => undoEdit()}
                  className="flex items-center text-sm text-slate-900 dark:text-gray-300 cursor-pointer font-medium hover:text-slate-700 hover:dark:text-gray-100"
                >
                  <Undo2Icon className="mr-2 h-4 w-4" />
                  {t('common.cancel')}
                </button>
              </div>
            </div>
          )}
          <input
            type="file"
            id={fieldName}
            accept={accept ?? '*/*'}
            {...registerProps}
            onChange={handleFileChange}
            ref={inputRef}
            className={inputClassName(!!errors?.[fieldName]?.message)}
          />
        </div>
      </div>
      {errors?.[fieldName]?.message && (
        <p className="mt-1 text-sm text-red-600">{errors[fieldName].message}</p>
      )}
    </div>
  );
};

export { InputFile };
export type { InputFileProps };
