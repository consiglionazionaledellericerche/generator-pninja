import { useTranslation } from 'react-i18next';
import { Text } from 'react-aria-components';
import prettyBytes from 'pretty-bytes';

interface FormFieldInfoProps {
  validations: IFormFieldInfo;
}
interface IFormFieldInfo {
  min?: number;
  minbytes?: number;
  minlength?: number;
  max?: number;
  maxbytes?: number;
  maxlength?: number;
  pattern?: string | RegExp;
  required?: boolean;
  unique?: boolean;
}

const FormFieldInfoContents: React.FC<FormFieldInfoProps> = ({ validations }) => {
  const { t } = useTranslation();
  const messages = Object.keys(validations as IFormFieldInfo)
    .filter((key) => !['pattern', 'strength'].includes(key))
    .map((key) => {
      const typedKey = key as keyof IFormFieldInfo;
      if (['min', 'max', 'minlength', 'maxlength'].includes(typedKey)) {
        return t(`info.validations.${typedKey}`, { accepted: validations[typedKey] });
      }
      if (['minbytes', 'maxbytes'].includes(typedKey)) {
        return t(`info.validations.${typedKey}`, {
          accepted: prettyBytes(Number(validations[typedKey])),
        });
      }
      return t(`info.validations.${typedKey}`);
    });
  return Object.keys(validations).length
    ? messages.map((msg, index) => (
        <span key={index}>
          {msg}
          {index < messages.length - 1 && '; '}
        </span>
      ))
    : null;
};

const FormFieldInfo: React.FC<FormFieldInfoProps> = ({ validations, ...ariaProps }) => {
  return Object.keys(validations).length ? (
    <p className="text-sm mt-1">
      <Text slot="description">
        <FormFieldInfoContents validations={validations} {...ariaProps} />
      </Text>
    </p>
  ) : null;
};

export { FormFieldInfo, FormFieldInfoContents };
