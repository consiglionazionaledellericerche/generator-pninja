import { RegisterOptions, FieldValues } from 'react-hook-form';
import { useFormContext, useController } from 'react-hook-form';
import { FormLabelAria as FormLabel, FormErrorsAria as FormErrors } from './index';
import {
  TextField as TextFieldAria,
  TextFieldProps as TextFieldPropsAria,
  TextArea as TextAreaAria,
} from 'react-aria-components';
import { useTextField } from 'react-aria';
import { useMemo, useRef, useEffect } from 'react';
import JoditEditor from 'jodit-react';
import type { IJodit } from 'jodit/types/types';
import { InfoValidations } from './InfoValidations';
import { useTranslation, getI18n } from 'react-i18next';
import './Textarea.css';

interface TextareaProps extends Omit<TextFieldPropsAria, 'isInvalid' | 'children'> {
  fieldName: string;
  label: string;
  placeholder?: string;
  rows?: number;
  editor?: boolean;
  validations?: {
    required?: boolean;
  };
}

const Textarea: React.FC<TextareaProps> = ({
  fieldName,
  label,
  rows,
  editor,
  validations,
  ...ariaProps
}) => {
  const { required } = validations || {};
  const { control, setValue } = useFormContext();
  const rules: RegisterOptions<FieldValues, string> | undefined = {};

  if (required) {
    rules.required = 'errors.validations.required';
  }

  const { t } = useTranslation();

  const {
    field,
    fieldState: { error },
  } = useController({
    name: fieldName,
    control,
    rules,
  });

  const cleanEmptyContent = (content: string): string => {
    if (!content) return '';
    const textOnly = content.replace(/<[^>]*>/g, '').trim();
    return textOnly.length === 0 ? '' : content;
  };

  const editorRef = useRef<IJodit | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const lastUserValue = useRef<string>('');

  const handleContentChange = (newContent: string) => {
    const cleanedContent = cleanEmptyContent(newContent);
    lastUserValue.current = cleanedContent;
    setValue(fieldName, cleanedContent, {
      shouldValidate: !!error,
      shouldDirty: true,
    });
  };

  const { labelProps, inputProps, errorMessageProps } = useTextField(
    { label, validationState: error ? 'invalid' : 'valid', errorMessage: error?.message },
    inputRef
  );

  useEffect(() => {
    if (!editorRef.current) return;
    const newValue = field.value || '';
    if (newValue !== lastUserValue.current) {
      editorRef.current.value = newValue;
      lastUserValue.current = newValue;
    }
  }, [field.value]);

  useEffect(() => {
    if (editorRef.current) {
      const editorElement = editorRef?.current.editor;
      if (editorElement) {
        field.ref(editorElement);
        editorElement.setAttribute('role', 'textbox');
        editorElement.setAttribute('aria-multiline', 'true');
        ['aria-labelledby' as const, 'aria-describedby' as const, 'aria-invalid' as const].forEach(
          (attr) => {
            if (inputProps[attr]) {
              editorElement.setAttribute(attr, String(inputProps[attr]));
            } else {
              editorElement.removeAttribute(attr);
            }
          }
        );
        const toolbar = editorElement
          .closest('.jodit-container')
          ?.querySelector('.jodit-toolbar__box');
        if (toolbar && !toolbar.hasAttribute('aria-label')) {
          toolbar.setAttribute('aria-label', 'Toolbar');
          toolbar.setAttribute('role', 'toolbar');
        }
      }
    }
  }, [inputProps, field]);

  const joditConfig = useMemo(
    () => ({
      aria: true,
      readonly: false,
      disabled: false,
      tabIndex: 0,
      allowTabNavigation: true,
      hidePoweredByJodit: true,
      showPlaceholder: false,
      minHeight: rows ? rows * 24 : 96,
      toolbar: true,
      spellcheck: true,
      language: getI18n().language,
      toolbarButtonSize: 'small' as const,
      toolbarAdaptive: false,
      buttons: [
        'undo',
        'redo',
        '|',
        'cut',
        'copy',
        'paste',
        '|',
        'paragraph',
        '|',
        'bold',
        'italic',
        '|',
        'ul',
        'ol',
        '|',
        'left',
        'center',
        'right',
        'justify',
        '|',
        'table',
        'symbols',
        '|',
        'link',
        'image',
        'video',
        '|',
        'source',
      ],
      uploader: {
        insertImageAsBase64URI: true,
      },
    }),
    [rows]
  );

  const [message, accepted, actual] = error?.message?.split(':') || [];

  return editor ? (
    <div>
      <div className="flex items-center gap-1">
        <label className="text-sm font-medium" {...labelProps}>
          {label}
        </label>
        <InfoValidations validations={validations ?? {}} />
      </div>
      <div
        className={
          error
            ? 'form-field-error p-1'
            : 'form-field focus-within:outline-2 focus-within:-outline-offset-2 focus-within:outline-blue-600! focus-within:dark:outline-blue-500! p-1'
        }
        ref={inputRef}
      >
        <JoditEditor
          ref={(instance) => {
            editorRef.current = instance;
          }}
          value={''}
          config={joditConfig}
          onBlur={handleContentChange}
          onChange={handleContentChange}
        />
      </div>
      {error?.message && (
        <p {...errorMessageProps} className="mt-1 text-sm text-red-600 dark:text-red-500">
          {t(message, { accepted, actual: actual })}
        </p>
      )}
    </div>
  ) : (
    <TextFieldAria isInvalid={!!error} {...ariaProps}>
      <FormLabel validations={validations}>{label}</FormLabel>
      <TextAreaAria rows={rows || 4} {...field} value={field.value || ''} className="form-field" />
      <FormErrors error={error} />
    </TextFieldAria>
  );
};
export { Textarea };
