import { RegisterOptions, FieldValues } from 'react-hook-form';
import { useFormContext, useController } from 'react-hook-form';
import {
  FormLabel,
  FormErrors,
  FormFieldInfo,
  FormFieldInfoContents,
} from './index';
import {
  TextField as TextFieldAria,
  TextFieldProps as TextFieldPropsAria,
  TextArea as TextAreaAria,
} from 'react-aria-components';
import { useId } from 'react-aria';
import { useMemo, useRef, useEffect } from 'react';
import JoditEditor from 'jodit-react';
import type { IJodit } from 'jodit/types/types';
import { useTranslation, getI18n } from 'react-i18next';
import './Textarea.css';

interface TextareaProps extends Omit<TextFieldPropsAria, 'isInvalid' | 'isRequired' | 'children'> {
  fieldName: string;
  label: string;
  placeholder?: string;
  rows?: number;
  editor?: boolean;
  validations?: {
    required?: boolean;
  };
}

const Textarea: React.FC<TextareaProps> = ({
  fieldName,
  label,
  rows,
  editor,
  validations,
  ...ariaProps
}) => {
  const { required } = validations || {};
  const { control, setValue } = useFormContext();
  const rules: RegisterOptions<FieldValues, string> | undefined = {};

  if (required) {
    rules.required = 'errors.validations.required';
  }

  const { t } = useTranslation();

  const {
    field,
    fieldState: { error },
  } = useController({
    name: fieldName,
    control,
    rules,
  });

  const cleanEmptyContent = (content: string): string => {
    if (!content) return '';
    const textOnly = content.replace(/<[^>]*>/g, '').trim();
    return textOnly.length === 0 ? '' : content;
  };

  const editorRef = useRef<IJodit | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const lastUserValue = useRef<string>('');

  const handleContentChange = (newContent: string) => {
    const cleanedContent = cleanEmptyContent(newContent);
    lastUserValue.current = cleanedContent;
    setValue(fieldName, cleanedContent, {
      shouldValidate: !!error,
      shouldDirty: true,
    });
  };

  const labelId = useId();
  const descriptionId = useId();
  const errorId = useId();

  useEffect(() => {
    if (!editorRef.current) return;
    const newValue = field.value || '';
    if (newValue !== lastUserValue.current) {
      editorRef.current.value = newValue;
      lastUserValue.current = newValue;
    }
  }, [field.value]);

  useEffect(() => {
    if (editorRef.current) {
      const editorElement = editorRef?.current.editor;
      if (editorElement) {
        field.ref(editorElement);
        editorElement.setAttribute('role', 'textbox');
        editorElement.setAttribute('aria-multiline', 'true');
        editorElement.setAttribute('aria-labelledby', labelId);
        if (error || validations)
          editorElement.setAttribute(
            'aria-describedby',
            [validations ? descriptionId : '', error ? errorId : ''].join(' ').trim()
          );
        else {
          editorElement.removeAttribute('aria-describedby');
        }
        if (error) {
          editorElement.setAttribute('aria-invalid', 'true');
        } else {
          editorElement.removeAttribute('aria-invalid');
        }
        const toolbar = editorElement
          .closest('.jodit-container')
          ?.querySelector('.jodit-toolbar__box');
        if (toolbar && !toolbar.hasAttribute('aria-label')) {
          toolbar.setAttribute('aria-label', 'Toolbar');
          toolbar.setAttribute('role', 'toolbar');
        }
      }
    }
  }, [field, error, validations, labelId, descriptionId, errorId]);

  const joditConfig = useMemo(
    () => ({
      aria: true,
      readonly: ariaProps.isReadOnly || false,
      disabled: ariaProps.isDisabled || false,
      tabIndex: 0,
      allowTabNavigation: true,
      hidePoweredByJodit: true,
      showPlaceholder: false,
      minHeight: rows ? rows * 24 : 96,
      toolbar: true,
      spellcheck: true,
      language: getI18n().language,
      toolbarButtonSize: 'small' as const,
      toolbarAdaptive: false,
      buttons: [
        'undo',
        'redo',
        '|',
        'cut',
        'copy',
        'paste',
        '|',
        'paragraph',
        '|',
        'bold',
        'italic',
        '|',
        'ul',
        'ol',
        '|',
        'left',
        'center',
        'right',
        'justify',
        '|',
        'table',
        'symbols',
        '|',
        'link',
        'image',
        'video',
        '|',
        'source',
      ],
      uploader: {
        insertImageAsBase64URI: true,
      },
    }),
    [rows]
  );

  const [message, accepted, actual] = error?.message?.split(':') || [];

  return editor ? (
    <div>
      <FormLabel id={labelId} validations={validations}>
        {label}
      </FormLabel>
      <div
        className={
          error
            ? 'form-field-error p-1'
            : 'form-field focus-within:outline-3 focus-within:outline-offset-3 focus-within:outline-blue-600! focus-within:dark:outline-sky-300! p-1'
        }
        ref={inputRef}
      >
        <JoditEditor
          ref={(instance) => {
            editorRef.current = instance;
          }}
          value={''}
          config={joditConfig}
          onBlur={handleContentChange}
          onChange={handleContentChange}
        />
      </div>
      {error?.message && (
        <p id={errorId} role="alert" className="mt-1 text-sm text-red-600 dark:text-red-500">
          {t(message, { accepted, actual: actual })}
        </p>
      )}
      {!error?.message && validations && Object.keys(validations).length > 0 && (
        <p className="text-sm" id={descriptionId}>
          <FormFieldInfoContents validations={validations} {...ariaProps} />
        </p>
      )}
    </div>
  ) : (
    <TextFieldAria isInvalid={!!error} {...ariaProps}>
      <FormLabel validations={validations}>{label}</FormLabel>
      <TextAreaAria rows={rows || 4} {...field} value={field.value || ''} className="form-field" />
      {!error && <FormFieldInfo validations={validations || {}} />}
      <FormErrors error={error} />
    </TextFieldAria>
  );
};
export { Textarea };
