import { useState, useEffect, useCallback, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useFocusWithin } from 'react-aria';
import type { Selection } from 'react-aria-components';
import {
  Button,
  Input,
  Label,
  ListBox,
  ListBoxItem,
  SearchField,
  SearchFieldProps as SearchFieldPropsAria,
  TagGroup,
  TagList,
  Tag,
} from 'react-aria-components';
import {
  IconSelector,
  IconSearch,
  IconSquare,
  IconSquareCheckFilled,
  IconX as X,
} from '@tabler/icons-react';
import { AxiosError } from 'axios';
import axiosInstance from '../../shared/axiosInstance';
import { ErrorResponseData, useNotifications } from '../../contexts/NotificationContext';
import { useFormContext, useController } from 'react-hook-form';
import { useAsyncList } from 'react-stately';
import { Collection, ListBoxLoadMoreItem } from 'react-aria-components';
import { FormLabel, FormErrors, FormFieldInfo } from './index';

const tagClassName = `
focus:outline-0 focus:bg-slate-800! focus:text-slate-200! focus:dark:bg-slate-50! focus:dark:text-slate-800!
focus-within:outline-0 focus-within:bg-slate-800! focus-within:text-slate-200! focus-within:dark:bg-slate-50! focus-within:dark:text-slate-800!
cursor-pointer inline-flex items-center gap-1 rounded-md
bg-slate-700 text-slate-200 dark:bg-slate-300 dark:text-slate-800
px-2 py-1 text-md font-medium flex-shrink-0
`;
const listItemClassName = `
group flex items-center gap-2
cursor-pointer px-3 py-1.5 rounded-md m-1
focus:outline-2 focus:outline-slate-800 focus:dark:outline-slate-50
`;

interface ISelectFieldOption {
  name: number | string;
  id: number | string | undefined;
}

interface ISelectFieldOptionsLoad {
  url: string;
  valueAttribute?: string;
  getValue?: (item: Record<string, unknown>) => string | number | undefined;
  labelAttribute?: string;
  getLabel?: (item: Record<string, unknown>) => string | number | undefined;
  searchParam?: string;
  perPageParam?: string;
  pageParam?: string;
  sortByParam?: string;
  sortDirectionParam?: string;
  perPage?: number;
  searchable?: boolean;
}

interface SelectFieldBase
  extends Omit<SearchFieldPropsAria, 'type' | 'isInvalid' | 'onChange' | 'onFocus' | 'children'> {
  fieldName: string;
  label: string;
  multiple?: boolean;
  validations?: {
    required?: boolean;
  };
  initialValue?: (number | string | undefined | null) | (number | string | undefined | null)[];
  sortBy?: 'label' | 'value';
  sortDirection?: 'asc' | 'desc';
  placeholder?: string;
}

interface SelectFieldWithOptions extends SelectFieldBase {
  options: ISelectFieldOption[];
  optionsLoad?: never;
}

interface SelectFieldWithOptionsLoad extends SelectFieldBase {
  options?: never;
  optionsLoad: ISelectFieldOptionsLoad;
}

type SelectFieldProps = SelectFieldWithOptions | SelectFieldWithOptionsLoad;

interface PaginatedResponse {
  data: Record<string, unknown>[];
  current_page: number;
  last_page: number;
  per_page: number;
  total: number;
}

const SelectField: React.FC<SelectFieldProps> = ({
  fieldName,
  label,
  multiple = false,
  options,
  validations,
  initialValue,
  sortDirection = 'asc',
  placeholder,
  ...props
}) => {
  const optionsLoad = useMemo(() => {
    if (
      !(
        props.optionsLoad?.url ||
        props.optionsLoad?.valueAttribute ||
        props.optionsLoad?.getValue ||
        props.optionsLoad?.labelAttribute ||
        props.optionsLoad?.getLabel ||
        props.optionsLoad?.searchParam ||
        props.optionsLoad?.perPageParam ||
        props.optionsLoad?.pageParam ||
        props.optionsLoad?.sortByParam ||
        props.optionsLoad?.sortDirectionParam ||
        props.optionsLoad?.perPage ||
        props.optionsLoad?.searchable
      )
    )
      return null;

    return {
      url: props.optionsLoad.url,
      valueAttribute: props.optionsLoad.valueAttribute,
      getValue: props.optionsLoad.getValue,
      labelAttribute: props.optionsLoad.labelAttribute,
      getLabel: props.optionsLoad.getLabel,
      searchParam: props.optionsLoad.searchParam,
      perPageParam: props.optionsLoad.perPageParam,
      pageParam: props.optionsLoad.pageParam,
      sortByParam: props.optionsLoad.sortByParam,
      sortDirectionParam: props.optionsLoad.sortDirectionParam,
      perPage: props.optionsLoad.perPage,
      searchable: props.optionsLoad.searchable,
    };
  }, [
    props.optionsLoad?.url,
    props.optionsLoad?.valueAttribute,
    props.optionsLoad?.getValue,
    props.optionsLoad?.labelAttribute,
    props.optionsLoad?.getLabel,
    props.optionsLoad?.searchParam,
    props.optionsLoad?.perPageParam,
    props.optionsLoad?.pageParam,
    props.optionsLoad?.sortByParam,
    props.optionsLoad?.sortDirectionParam,
    props.optionsLoad?.perPage,
    props.optionsLoad?.searchable,
  ]);
  const { t } = useTranslation();
  const { required } = validations || {};
  const perPage = optionsLoad?.perPage ?? 10;
  const [selected, setSelected] = useState<Selection>(new Set([]));
  const searchable = optionsLoad?.searchable ?? true;
  const listboxId = `${fieldName}-listbox`;
  const { addNotification } = useNotifications();

  const list = useAsyncList<ISelectFieldOption>({
    async load({ signal, cursor, filterText }) {
      if (optionsLoad?.url) {
        try {
          const res = await axiosInstance.get(cursor || buildApiUrl(filterText, 1), {
            signal,
          });
          const { data = [], current_page = 1, last_page = 1 } = res?.data ?? {};
          return {
            items: data,
            cursor:
              current_page < last_page ? buildApiUrl(filterText, current_page + 1) : undefined,
          };
        } catch (error) {
          if (error instanceof DOMException && error.name === 'AbortError') {
            return { items: [], cursor: undefined };
          }
          addNotification({
            type: 'error',
            message: `${t('errors.options.load', { entity: label })}`,
            error: error as AxiosError<ErrorResponseData>,
          });
          return {
            items: [],
            cursor: undefined,
          };
        }
      } else {
        if (!searchTerm) {
          return {
            items: options || [],
            cursor: undefined,
          };
        } else {
          return {
            items: (options || []).filter(
              (opt) =>
                String(opt?.name).toLowerCase().includes(searchTerm.toLowerCase()) ||
                String(opt?.id).toLowerCase().includes(searchTerm.toLowerCase())
            ),
            cursor: undefined,
          };
        }
      }
    },
  });

  const buildApiUrl = useCallback(
    (search = '', page = 1) => {
      if (!optionsLoad?.url) return '';

      const url = new URL(optionsLoad.url, window.location.origin);

      if (search) {
        url.searchParams.set(optionsLoad.searchParam ?? 'search', search);
      }

      url.searchParams.set(optionsLoad.pageParam ?? 'page', page.toString());
      url.searchParams.set(optionsLoad.perPageParam ?? 'per_page', perPage.toString());
      url.searchParams.set(
        optionsLoad.sortByParam ?? 'sort_by',
        optionsLoad.labelAttribute ?? 'id'
      );
      url.searchParams.set(optionsLoad.sortDirectionParam ?? 'sort_direction', sortDirection);

      return url.toString();
    },
    [optionsLoad, sortDirection, perPage]
  );

  const [listIsOpen, setListIsOpen] = useState(false);
  const { focusWithinProps } = useFocusWithin({
    onBlurWithin: () => {
      onBlur();
      setListIsOpen(false);
    },
  });

  const [searchTerm, setSearchTerm] = useState('');
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      list.setFilterText(searchTerm);
    }, 300);
    return () => clearTimeout(timeoutId);
  }, [searchTerm]);

  const [selectedOptions, setSelectedOptions] = useState<ISelectFieldOption[]>([]);
  const { control, setValue } = useFormContext();

  const initValue = useMemo(
    () => initialValue,
    [JSON.stringify(Array.isArray(initialValue) ? [...initialValue].sort() : initialValue)]
  );

  const { field, fieldState } = useController({
    name: fieldName,
    control,
    defaultValue: multiple
      ? Array.isArray(initValue)
        ? initValue.map((v) => String(v))
        : []
      : initValue
        ? String(initValue)
        : '',
    rules: {
      validate: (v) => {
        if (!required) return true;
        if (!v) return 'errors.validations.required';
        return (Array.isArray(v) ? v : [v]).length > 0 ? true : 'errors.validations.required';
      },
    },
  });

  const { onBlur, ref } = field;
  const { error } = fieldState;

  const getValue = useCallback(
    (item: Record<string, unknown>): number | string | undefined =>
      optionsLoad?.getValue
        ? optionsLoad.getValue(item)
        : ((item[optionsLoad?.valueAttribute ?? 'id'] ?? undefined) as number | string | undefined),
    [optionsLoad]
  );

  const getLabel = useCallback(
    (item: Record<string, unknown>): string =>
      optionsLoad?.getLabel
        ? String(optionsLoad?.getLabel(item))
        : String(item[optionsLoad?.labelAttribute ?? optionsLoad?.valueAttribute ?? 'id']),
    [optionsLoad]
  );

  const loadSelectedValues = useCallback(
    async (values: (string | number)[]) => {
      if (!optionsLoad?.url || values.length === 0) return [];

      try {
        const url = new URL(String(optionsLoad?.url), window.location.origin);
        url.searchParams.set('ids', values.join(','));
        url.searchParams.set('per_page', values.length.toString());

        const response = await axiosInstance.get(url.toString());
        const result: PaginatedResponse = await response?.data;

        return result.data.map((item) => ({
          name: getLabel(item),
          id: getValue(item),
        }));
      } catch (error) {
        addNotification({
          type: 'error',
          message: `${t('errors.options.load', { entity: label })}`,
          error: error as AxiosError<ErrorResponseData>,
        });
        return [];
      }
    },
    [optionsLoad?.url, getLabel, getValue, addNotification, t, label]
  );

  // Handler per rimuovere tag
  const handleRemoveTag = (idToRemove: string | number) => {
    setSelected((prevSelected) => {
      const newSelected = new Set(
        [...prevSelected].filter((id) => String(id) !== String(idToRemove))
      );

      const formValue = multiple ? Array.from(newSelected) : (Array.from(newSelected)[0] ?? '');
      setValue(fieldName, formValue, { shouldValidate: true, shouldDirty: true });

      return newSelected;
    });
  };

  // Handler per cambio selezione dalla ListBox
  const handleSelectionChange = (newSelection: Selection) => {
    setSelected(newSelection);

    const formValue = multiple ? Array.from(newSelection) : (Array.from(newSelection)[0] ?? '');
    setValue(fieldName, formValue, { shouldValidate: true, shouldDirty: true });
  };

  // Carica i dettagli delle opzioni selezionate
  useEffect(() => {
    const run = async () => {
      if (optionsLoad?.url) {
        const selectedFromApi = await loadSelectedValues(Array.from(selected));
        setSelectedOptions(selectedFromApi);
      } else if (options) {
        const selectedOpts = options.filter((option) =>
          Array.from(selected).some((val) => String(val) === String(option.id))
        );
        setSelectedOptions(selectedOpts);
      }
    };
    run();
  }, [selected, loadSelectedValues, options, optionsLoad]);

  // Inizializza selected quando initValue cambia
  useEffect(() => {
    const newSelected = new Set(
      Array.isArray(initValue)
        ? initValue.map((v) => String(v))
        : initValue
          ? [String(initValue)]
          : []
    );

    setSelected(newSelected);

    // Imposta anche il valore nel form
    const formValue = multiple ? Array.from(newSelected) : (Array.from(newSelected)[0] ?? '');
    setValue(fieldName, formValue);
  }, [initValue, multiple, fieldName, setValue]);

  return (
    <div {...focusWithinProps}>
      <SearchField
        {...props}
        isInvalid={!!error}
        onChange={setSearchTerm}
        onFocus={() => setListIsOpen(true)}
        aria-haspopup="listbox"
      >
        <FormLabel validations={validations}>{label}</FormLabel>
        <div
          className={`
          scheme-light dark:scheme-dark outline-0 rounded-md border-none bg-slate-200 text-slate-800 dark:bg-slate-600 dark:text-slate-200 placeholder-slate-600 dark:placeholder-slate-300 text-sm/6 py-1.5 px-2
          ${error ? ' outline-2 -outline-offset-2 outline-red-600 dark:outline-red-500 focus-within:outline-2 focus-within:outline-0' : ' focus-within:outline-2 focus-within:outline-offset-2 focus-within:outline-blue-600 focus-within:dark:outline-sky-300'}
          `}
        >
          <div className={`group flex items-center w-full`}>
            <IconSearch aria-hidden className="size-5 text-slate-600 dark:text-slate-300" />
            <Input
              ref={ref}
              placeholder={
                placeholder ||
                (searchable
                  ? multiple
                    ? t('common.select.searchMultiple')
                    : t('common.select.searchSingle')
                  : multiple
                    ? t('common.select.selectMultiple')
                    : t('common.select.selectSingle'))
              }
              className="px-2 flex-1 min-w-0 border-none outline-0 placeholder-slate-600 dark:placeholder-slate-300 font-[inherit] [&::-webkit-search-cancel-button]:hidden"
              aria-controls={listIsOpen ? listboxId : undefined}
              aria-expanded={listIsOpen}
            />
            {searchTerm && (
              <Button
                aria-label={t('common.cancel')}
                className="size-6 box-content text-md text-center transition rounded-full border-0 p-1 flex items-center justify-center text-slate-600 dark:text-slate-300 bg-transparent hover:bg-black/[15%] pressed:bg-black/10 group-empty:invisible"
              >
                <X aria-hidden className="size-5" />
              </Button>
            )}
            <button
              type="button"
              aria-label={listIsOpen ? t('common.select.collapse') : t('common.select.expand')}
              className="size-6 box-content focus:outline-0 focus:ring-2 text-md text-center transition rounded-full border-0 p-1 flex items-center justify-center text-slate-600 dark:text-slate-300 bg-transparent hover:bg-black/[15%] pressed:bg-black/10 group-empty:invisible"
              aria-expanded={listIsOpen}
              onClick={() => setListIsOpen((prev) => !prev)}
            >
              <IconSelector aria-hidden className="size-5" />
            </button>
          </div>
          {selectedOptions.length > 0 && (
            <TagGroup
              onRemove={(keys) => {
                handleRemoveTag([...keys][0]);
              }}
            >
              <TagList
                className="flex flex-wrap gap-1 w-full mt-1"
                items={selectedOptions}
                renderEmptyState={() => null}
              >
                {selectedOptions.map((option) => (
                  <Tag
                    id={option.id ? String(option.id) : undefined}
                    key={option.id}
                    className={tagClassName}
                    textValue={String(option.name)}
                  >
                    {option.name}
                    <Button
                      slot="remove"
                      className="cursor-pointer p-1 rounded-full outline-0 focus:ring-2 hover:bg-black/20 pressed:bg-black/10 hover:dark:bg-white/80 pressed:dark:bg-white/90"
                    >
                      <X aria-hidden className="size-4" />
                    </Button>
                  </Tag>
                ))}
              </TagList>
              <Label>
                {t(
                  selectedOptions.length === 1
                    ? 'common.select.oneElementSelected'
                    : 'common.select.nElementsSelected',
                  { count: selectedOptions.length }
                )}
              </Label>
            </TagGroup>
          )}
        </div>
        {listIsOpen && (
          <div className="relative">
            {list.items.length > 0 ? (
              <ListBox
                aria-label={
                  multiple ? t('common.select.selectMultiple') : t('common.select.selectSingle')
                }
                id={listboxId}
                onFocusChange={setListIsOpen}
                selectionBehavior="toggle"
                selectionMode={multiple ? 'multiple' : 'single'}
                selectedKeys={selected}
                onSelectionChange={handleSelectionChange}
                renderEmptyState={() => ''}
                className="
            absolute z-10 top-0 right-0 left-0
            mt-1 max-h-60 w-full overflow-auto rounded-md bg-slate-300 text-slate-800 dark:bg-slate-700 dark:text-slate-200 shadow-md dark:shadow-md/70 focus:outline-none
            "
              >
                <Collection
                  items={list.items
                    // .filter((item) => !selectedOptions.map((opt) => opt.id).includes(item.id))
                    .map((item) => ({
                      id: String(getValue(item as unknown as Record<string, unknown>)),
                      name: getLabel(item as unknown as Record<string, unknown>),
                    }))}
                >
                  {(item) => (
                    <ListBoxItem
                      key={item.id}
                      textValue={item.name}
                      className={listItemClassName}
                      id={item.id}
                    >
                      <IconSquare aria-hidden className="size-5 group-data-[selected]:hidden" />
                      <IconSquareCheckFilled
                        aria-hidden
                        className="size-5 hidden group-data-[selected]:block"
                      />
                      {item.name}
                    </ListBoxItem>
                  )}
                </Collection>
                <ListBoxLoadMoreItem
                  onLoadMore={list.loadMore}
                  isLoading={list.loadingState === 'loadingMore'}
                >
                  <div className="mx-auto my-4 animate-spin rounded-full size-6 border-b-2"></div>
                </ListBoxLoadMoreItem>
              </ListBox>
            ) : (
              <div className="absolute z-10 top-0 right-0 left-0 mt-1 w-full rounded-md bg-slate-300 text-slate-800 dark:bg-slate-700 dark:text-slate-200 shadow-md dark:shadow-md/70 p-3">
                {t('common.select.noOptions')}
              </div>
            )}
          </div>
        )}
        {!error && <FormFieldInfo validations={validations || {}} />}
        <FormErrors error={error} />
      </SearchField>
    </div>
  );
};

export { SelectField };
