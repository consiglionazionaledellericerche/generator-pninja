import { useEffect, useState, useRef, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { ChevronsUpDown, Search, X } from 'lucide-react';
import { useFormContext } from 'react-hook-form';
import { FormLabel } from './FormLabel';
import { FormErrors } from './FormErrors';
import { useNotifications } from '../../contexts/NotificationContext';
import { useApi } from '../../hooks/useApi';
import { HttpError } from '../../hooks/useApi';

const inputWrapperClassName = (hasErrors = false) =>
  `scheme-light dark:scheme-dark outline-0${hasErrors ? ' outline-2 -outline-offset-2 outline-red-500' : ''} focus-within:outline-2 focus-within:-outline-offset-2 ${hasErrors ? 'focus-within:outline-red-500' : 'focus-within:outline-blue-600'} rounded-md flex flex-wrap items-center gap-1 w-full mt-3 border-none bg-slate-200 text-slate-900 dark:bg-gray-800 dark:text-gray-300 text-sm/6 py-1.5 px-2 min-h-[38px]`;
const searchInputClassName =
  'outline-none bg-transparent flex-1 min-w-[20em] text-base placeholder:text-gray-400';
const dropdownClassName =
  'absolute z-50 mt-1 max-h-60 w-full overflow-auto rounded-md bg-slate-200 dark:bg-gray-800 py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none';
const optionClassName = (isSelected = false, isHighlighted = false) =>
  `relative cursor-pointer select-none py-2 px-3 text-slate-900 dark:text-gray-300 ${
    isHighlighted
      ? 'bg-blue-600 text-white'
      : isSelected
        ? 'bg-slate-300 dark:bg-gray-700'
        : 'hover:bg-slate-300 dark:hover:bg-gray-700'
  }`;
const tagClassName =
  'inline-flex items-center gap-1 rounded-md bg-blue-600 px-2 py-1 text-sm font-medium text-white flex-shrink-0';

interface ISelectFieldOption {
  label: number | string;
  value: number | string | undefined;
}

interface ISelectFieldOptionsLoad {
  url: string;
  valueAttribute?: string;
  getValue?: (item: Record<string, unknown>) => string | number | undefined;
  labelAttribute?: string;
  getLabel?: (item: Record<string, unknown>) => string | number | undefined;
  searchParam?: string;
  perPageParam?: string;
  pageParam?: string;
  sortByParam?: string;
  sortDirectionParam?: string;
  perPage?: number;
  searchable?: boolean;
}

interface SelectFieldBase {
  fieldName: string;
  label: string;
  multiple?: boolean;
  validations?: {
    required?: boolean;
  };
  defaultValue?: (number | string | undefined | null) | (number | string | undefined | null)[];
  sortBy?: 'label' | 'value';
  sortDirection?: 'asc' | 'desc';
  placeholder?: string;
}

interface SelectFieldWithOptions extends SelectFieldBase {
  options: ISelectFieldOption[];
  optionsLoad?: never;
}

interface SelectFieldWithOptionsLoad extends SelectFieldBase {
  options?: never;
  optionsLoad: ISelectFieldOptionsLoad;
}

type SelectFieldProps = SelectFieldWithOptions | SelectFieldWithOptionsLoad;

interface PaginatedResponse {
  data: Record<string, unknown>[];
  current_page: number;
  last_page: number;
  per_page: number;
  total: number;
}

const SelectField: React.FC<SelectFieldProps> = ({
  fieldName,
  label,
  multiple = false,
  options,
  optionsLoad,
  validations,
  defaultValue,
  sortBy = 'label',
  sortDirection = 'asc',
  placeholder,
}) => {
  const searchable = optionsLoad?.searchable ?? true;
  const { t } = useTranslation();
  const { addNotification } = useNotifications();
  const { required } = validations || {};
  const { fetch } = useApi();

  const [isOpen, setIsOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [allOptions, setAllOptions] = useState<ISelectFieldOption[]>([]);
  const [filteredOptions, setFilteredOptions] = useState<ISelectFieldOption[]>([]);
  const [loading, setLoading] = useState(false);
  const [hasMorePages, setHasMorePages] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [selectedOptions, setSelectedOptions] = useState<ISelectFieldOption[]>([]);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  const [initialValuesLoaded, setInitialValuesLoaded] = useState(false);

  const containerRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const scrollPositionBeforeLoadRef = useRef<number>(0);

  const {
    register,
    formState: { errors },
    setValue,
    getValues,
  } = useFormContext();

  const getValue = useCallback(
    (item: Record<string, unknown>): number | string | undefined =>
      optionsLoad?.getValue
        ? optionsLoad.getValue(item)
        : ((item[optionsLoad?.valueAttribute ?? 'id'] ?? undefined) as number | string | undefined),
    [optionsLoad]
  );

  const getLabel = useCallback(
    (item: Record<string, unknown>): string =>
      optionsLoad?.getLabel
        ? String(optionsLoad?.getLabel(item))
        : String(item[optionsLoad?.labelAttribute ?? optionsLoad?.valueAttribute ?? 'id']),
    [optionsLoad]
  );

  const loadSelectedValues = useCallback(
    async (values: (string | number)[]) => {
      if (!optionsLoad?.url || values.length === 0) return [];

      try {
        const url = new URL(optionsLoad.url, window.location.origin);
        url.searchParams.set('ids', values.join(','));
        url.searchParams.set('per_page', '100');

        const response = await fetch(url.toString());
        const result: PaginatedResponse = await response.json();

        return result.data.map((item) => ({
          label: getLabel(item),
          value: getValue(item),
        }));
      } catch (error) {
        console.error('Error loading selected values:', error);
        return [];
      }
    },
    [optionsLoad?.url, fetch, getValue, getLabel]
  );

  const buildApiUrl = useCallback(
    (search = '', page = 1) => {
      if (!optionsLoad?.url) return '';

      const url = new URL(optionsLoad.url, window.location.origin);

      if (search) {
        url.searchParams.set(optionsLoad.searchParam ?? 'search', search);
      }

      url.searchParams.set(optionsLoad.pageParam ?? 'page', page.toString());
      url.searchParams.set(
        optionsLoad.perPageParam ?? 'per_page',
        (optionsLoad.perPage ?? 20).toString()
      );
      url.searchParams.set(
        optionsLoad.sortByParam ?? 'sort_by',
        optionsLoad.labelAttribute ?? 'id'
      );
      url.searchParams.set(optionsLoad.sortDirectionParam ?? 'sort_direction', sortDirection);

      return url.toString();
    },
    [optionsLoad, sortDirection]
  );

  const fetchOptions = useCallback(
    async (search = '', page = 1, append = false) => {
      if (!optionsLoad?.url) return;

      // Save the scroll position before loading new options
      if (append && dropdownRef.current) {
        scrollPositionBeforeLoadRef.current = dropdownRef.current.scrollTop;
      }

      setLoading(true);
      try {
        const response = await fetch(buildApiUrl(search, page));
        const result: PaginatedResponse = await response.json();

        const newOptions = result.data.map((item) => ({
          label: getLabel(item),
          value: getValue(item),
        }));

        if (append) {
          setAllOptions((prev) => {
            const combined = [...prev, ...newOptions];
            // Schedule scroll restoration after DOM update
            setTimeout(() => {
              if (dropdownRef.current) {
                const optionHeight = 40; // approximate height of an option
                const newItemsStartPosition = prev.length * optionHeight;
                // Show a couple of previous options for context
                const scrollToPosition = Math.max(0, newItemsStartPosition - optionHeight * 2);
                dropdownRef.current.scrollTop = scrollToPosition;
              }
            }, 0);
            return combined;
          });
        } else {
          setAllOptions(newOptions);
        }

        setHasMorePages(result.current_page < result.last_page);
        setCurrentPage(result.current_page);
      } catch (error: unknown) {
        console.error('Error fetching options:', error);
        setAllOptions([]);
        addNotification({
          type: 'error',
          message: `${t('errors.options.load')}`,
          details: error instanceof Error ? error.message : undefined,
          techDetails: error instanceof HttpError ? error.details : undefined,
          duration: 10000,
        });
      }
      setLoading(false);
    },
    [buildApiUrl, fetch, getValue, getLabel, addNotification, t, optionsLoad?.url]
  );

  const loadMoreOptions = useCallback(() => {
    if (hasMorePages && !loading) {
      fetchOptions(searchTerm, currentPage + 1, true);
    }
  }, [fetchOptions, searchTerm, currentPage, hasMorePages, loading]);

  useEffect(() => {
    const loadInitialValues = async () => {
      if (initialValuesLoaded) return;

      const currentValue = getValues(fieldName) || defaultValue;
      if (!currentValue) {
        setInitialValuesLoaded(true);
        return;
      }

      const valueArray = multiple
        ? Array.isArray(currentValue)
          ? currentValue
          : [currentValue]
        : [currentValue];

      if (optionsLoad?.url) {
        const selectedFromApi = await loadSelectedValues(valueArray);
        setSelectedOptions(selectedFromApi);
      } else if (options) {
        const selected = options.filter((option) =>
          valueArray.some((val) => String(val) === String(option.value))
        );
        setSelectedOptions(selected);
      }

      setInitialValuesLoaded(true);
    };

    loadInitialValues();
  }, [
    fieldName,
    defaultValue,
    multiple,
    options,
    optionsLoad,
    getValues,
    loadSelectedValues,
    initialValuesLoaded,
  ]);

  useEffect(() => {
    if (options) {
      const sortedOptions = [...options].sort((a, b) => {
        const aVal = sortBy === 'label' ? String(a.label) : String(a.value);
        const bVal = sortBy === 'label' ? String(b.label) : String(b.value);
        const result = aVal.localeCompare(bVal, undefined, { numeric: true });
        return sortDirection === 'desc' ? -result : result;
      });
      setAllOptions(sortedOptions);
    }
  }, [options, sortBy, sortDirection]);

  useEffect(() => {
    if (optionsLoad?.url && initialValuesLoaded) {
      fetchOptions('', 1, false);
    }
  }, [fetchOptions, optionsLoad?.url, initialValuesLoaded]);

  useEffect(() => {
    let filtered: ISelectFieldOption[] = [];

    if (!searchable || !searchTerm) {
      filtered = [...allOptions];
    } else if (optionsLoad?.url) {
      filtered = [...allOptions];
    } else {
      filtered = allOptions.filter(
        (option) =>
          String(option.label).toLowerCase().includes(searchTerm.toLowerCase()) ||
          String(option.value).toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    // Remove already selected options from the dropdown
    const availableOptions = multiple
      ? filtered.filter(
          (option) =>
            !selectedOptions.some((selected) => String(selected.value) === String(option.value))
        )
      : filtered;

    setFilteredOptions(
      multiple ? availableOptions : [{ label: '\xA0', value: '' }, ...availableOptions]
    );
  }, [allOptions, searchTerm, searchable, optionsLoad?.url, selectedOptions, multiple]);

  useEffect(() => {
    if (!optionsLoad?.url || !searchable || !initialValuesLoaded) return;

    const timeoutId = setTimeout(() => {
      fetchOptions(searchTerm, 1, false);
      setCurrentPage(1);
    }, 300);

    return () => clearTimeout(timeoutId);
  }, [searchTerm, fetchOptions, optionsLoad?.url, searchable, initialValuesLoaded]);

  useEffect(() => {
    setValue(fieldName, []); // call to trig setValueAs
  }, [selectedOptions, fieldName, multiple, setValue]);

  const handleSelect = (option: ISelectFieldOption) => {
    if (multiple) {
      const isSelected = selectedOptions.some(
        (selected) => String(selected.value) === String(option.value)
      );

      if (isSelected) {
        setSelectedOptions((prev) =>
          prev.filter((selected) => String(selected.value) !== String(option.value))
        );
      } else {
        setSelectedOptions((prev) => [...prev, option]);
      }
    } else {
      setSelectedOptions([option]);
      setIsOpen(false);
      setSearchTerm('');
    }
  };

  const handleRemoveTag = (optionToRemove: ISelectFieldOption) => {
    setSelectedOptions((prev) =>
      prev.filter((selected) => String(selected.value) !== String(optionToRemove.value))
    );
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (!isOpen) {
      if (e.key === 'Enter' || e.key === 'ArrowDown') {
        e.preventDefault();
        setIsOpen(true);
        setHighlightedIndex(0);
      }
      return;
    }

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setHighlightedIndex((prev) => (prev < filteredOptions.length - 1 ? prev + 1 : prev));
        break;
      case 'ArrowUp':
        e.preventDefault();
        setHighlightedIndex((prev) => (prev > 0 ? prev - 1 : 0));
        break;
      case 'Enter':
        e.preventDefault();
        if (highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {
          handleSelect(filteredOptions[highlightedIndex]);
        }
        break;
      case 'Escape':
        setIsOpen(false);
        setHighlightedIndex(-1);
        break;
    }
  };

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
    if (scrollHeight - scrollTop === clientHeight) {
      loadMoreOptions();
    }
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false);
        setHighlightedIndex(-1);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const displayValue =
    !multiple && selectedOptions.length > 0 ? String(selectedOptions[0].label) : '';

  const showDisplayValue = !multiple && selectedOptions.length > 0 && (!isOpen || !searchable);

  useEffect(() => {
    setValue(fieldName, []); // call to trig setValueAs
  }, [defaultValue, setValue, fieldName, multiple]);

  const OptionsSkeleton = () => (
    <div className="animate-pulse">
      {Array(20)
        .fill('')
        .map((_, index) => (
          <div
            key={index}
            className="relative cursor-pointer select-none py-2 px-3 text-slate-900 dark:text-gray-300 hover:bg-slate-300 dark:hover:bg-gray-700"
          >
            <div>
              <span className="rounded-md bg-gray-400 w-[70%] h-4 myy inline-block">&nbsp;</span>
            </div>
          </div>
        ))}
    </div>
  );

  return (
    <div ref={containerRef}>
      <FormLabel htmlFor={fieldName} label={label} validations={validations} />
      <div className="relative">
        <div className={inputWrapperClassName(!!errors?.[fieldName]?.message)}>
          {searchable && <Search className="text-gray-400 w-4 h-4 flex-shrink-0" />}
          <input
            ref={searchInputRef}
            type="text"
            id={fieldName}
            className={searchInputClassName}
            placeholder={
              placeholder ||
              (searchable
                ? multiple
                  ? t('common.select.searchMultiple')
                  : t('common.select.searchSingle')
                : multiple
                  ? t('common.select.selectMultiple')
                  : t('common.select.selectSingle'))
            }
            value={isOpen && searchable ? searchTerm : showDisplayValue ? displayValue : searchTerm}
            onChange={(e) => {
              if (searchable) {
                setSearchTerm(e.target.value);
                if (!isOpen) setIsOpen(true);
              }
            }}
            onFocus={() => {
              setIsOpen(true);
              if (searchable && !multiple) {
                setSearchTerm('');
              }
            }}
            onKeyDown={handleKeyDown}
            autoComplete="off"
          />

          <button
            type="button"
            className="text-gray-400 flex-shrink-0 p-1"
            onClick={() => setIsOpen(!isOpen)}
          >
            <ChevronsUpDown className="w-4 h-4" />
          </button>

          {multiple && selectedOptions.length > 0 && (
            <div className="flex flex-wrap gap-1 w-full">
              {selectedOptions.map((option) => (
                <span key={option.value} className={tagClassName}>
                  {option.label}
                  <button
                    type="button"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleRemoveTag(option);
                    }}
                    className="ml-1 hover:text-red-600 hover:bg-white rounded-full cursor-pointer"
                  >
                    <X className="w-4 h-4" />
                  </button>
                </span>
              ))}
            </div>
          )}
        </div>

        {isOpen && (
          <div ref={dropdownRef} className={dropdownClassName} onScroll={handleScroll}>
            {loading && currentPage === 1 ? (
              <OptionsSkeleton />
            ) : filteredOptions.length === 0 ? (
              <div className={optionClassName()}>{t('common.select.noOptions')}</div>
            ) : (
              <>
                {filteredOptions.map((option, index) => {
                  const isSelected = selectedOptions.some(
                    (selected) =>
                      String(selected.value) === String(option.value) && option.label !== '\xA0'
                  );
                  const isHighlighted = index === highlightedIndex;

                  return (
                    <div
                      key={`${option.value}-${index}`}
                      className={optionClassName(isSelected, isHighlighted)}
                      onClick={() => handleSelect(option)}
                      onMouseEnter={() => setHighlightedIndex(index)}
                    >
                      <span className="block truncate">
                        {option.label}
                        {isSelected && <span className="ml-2 text-xs">âœ“</span>}
                      </span>
                    </div>
                  );
                })}
                {loading && hasMorePages && <OptionsSkeleton />}
              </>
            )}
          </div>
        )}

        {multiple ? (
          <select
            multiple={multiple}
            className="h-0 w-0 overflow-hidden absolute"
            {...register(fieldName, {
              setValueAs: () => {
                return selectedOptions.map((option) => option.value);
              },
              validate: {
                required: () => {
                  if (!required) return true;
                  return selectedOptions.length > 0 ? true : 'errors.validations.required';
                },
              },
            })}
          />
        ) : (
          <input
            className="h-0 w-0 overflow-hidden absolute"
            {...register(fieldName, {
              setValueAs: () => {
                const values = selectedOptions.map((option) => option.value);
                return values[0] ?? '';
              },
              validate: {
                required: () => {
                  if (!required) return true;
                  return selectedOptions.length > 0 ? true : 'errors.validations.required';
                },
              },
            })}
          />
        )}
      </div>
      <FormErrors errors={errors} fieldName={fieldName} />
    </div>
  );
};

export { SelectField };
export type { ISelectFieldOption };
