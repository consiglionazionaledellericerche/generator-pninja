import { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { ChevronsUpDown } from 'lucide-react';
import { useFormContext } from 'react-hook-form';
import { FormLabel } from './FormLabel';
import { FormErrors } from './FormErrors';
import { useNotifications } from '../../contexts/NotificationContext';
import { useApi } from '../../hooks/useApi';
import { HttpError } from '../../hooks/useApi';

const selectContainerClassName = 'grid grid-cols-1';
const selectClassName = (hasErrors = false) =>
  `scheme-light dark:scheme-dark outline-0${hasErrors ? ' outline-2 -outline-offset-2 outline-red-500' : ''} focus:outline-2 focus:-outline-offset-2 ${hasErrors ? 'focus:outline-red-500' : 'focus:outline-blue-600'} rounded-md block w-full mt-3 border-none bg-slate-200 text-slate-900 dark:bg-gray-800 dark:text-gray-300 text-sm/6 py-1.5 p-2 text-base appearance-none col-start-1 row-start-1`;
const selectOptionClassName = `scheme-light dark:scheme-dark outline-0 hover:outline-2 hover:-outline-offset-2 hover:outline-blue-600 focus:outline-2 focus:-outline-offset-2 focus:outline-blue-600 rounded-md mt-1 border-none bg-slate-200 text-slate-900 dark:bg-gray-800 dark:text-gray-300 text-sm/6 py-1.5 px-3 text-base appearance-none checked:bg-slate-300 checked:text-black dark:checked:bg-gray-700 dark:checked:text-white`;
const selectChevronClassName =
  'pointer-events-none col-start-1 row-start-1 mt-3 mr-2 size-5 self-center justify-self-end text-gray-500 sm:size-4';

interface ISelectFieldOption {
  label: number | string;
  value: number | string | undefined;
}

interface ISelectFieldOptionsLoad {
  url: string;
  valueAttribute?: string;
  getValue?: (item: Record<string, unknown>) => string | number | undefined;
  labelAttribute?: string;
  getLabel?: (item: Record<string, unknown>) => string | number | undefined;
}

interface SelectFieldBase {
  fieldName: string;
  label: string;
  multiple?: boolean;
  size?: number;
  validations?: {
    required?: boolean;
  };
  defaultValue?: (number | string | undefined | null) | (number | string | undefined | null)[];
  sortBy?: 'label' | 'value' | 'label:asc' | 'value:asc' | 'label:desc' | 'value:desc';
}

interface SelectFieldWithOptions extends SelectFieldBase {
  options: ISelectFieldOption[];
  optionsLoad?: never; // if options is set, optionsLoad cannot be set
}

interface SelectFieldWithOptionsLoad extends SelectFieldBase {
  options?: never; // if optionsLoad is set, options cannot be set
  optionsLoad: ISelectFieldOptionsLoad;
}

type SelectFieldProps = SelectFieldWithOptions | SelectFieldWithOptionsLoad;

const SelectField: React.FC<SelectFieldProps> = ({
  fieldName,
  label,
  multiple = false,
  options,
  optionsLoad,
  size,
  validations,
  defaultValue,
  sortBy,
}) => {
  const { t } = useTranslation();
  const { addNotification } = useNotifications();
  const { required } = validations || {};
  const { fetch } = useApi();
  const [remoteOptions, setRemoteOptions] = useState<Record<string, unknown>[] | undefined>(
    undefined
  );
  const [loading, setLoading] = useState(false);

  const {
    register,
    formState: { errors },
    getValues,
    setValue,
  } = useFormContext();

  const optionsSorter = (a: ISelectFieldOption, b: ISelectFieldOption) => {
    let result: number;
    const [by, order] = (sortBy ?? 'value:asc').split(':');
    if (by === 'label') {
      result = String(a.label).localeCompare(String(b.label), undefined, { numeric: true });
    } else {
      result = String(a.value).localeCompare(String(b.value), undefined, { numeric: true });
    }
    return order === 'desc' ? -result : result;
  };

  const getValue = (item: Record<string, unknown>): number | string | undefined =>
    optionsLoad?.getValue
      ? optionsLoad.getValue(item)
      : ((item[optionsLoad?.valueAttribute ?? 'id'] ?? undefined) as number | string | undefined);

  const getLabel = (item: Record<string, unknown>): string =>
    optionsLoad?.getLabel
      ? String(optionsLoad?.getLabel(item))
      : String(item[optionsLoad?.labelAttribute ?? optionsLoad?.valueAttribute ?? 'id']);

  useEffect(() => {
    // Load options from the provided URL if optionsLoad is defined
    if (!optionsLoad?.url) return;
    const fetchOptions = async () => {
      setLoading(true);
      try {
        const reponse = await fetch(optionsLoad?.url ?? '');
        const responseData = await reponse.json();
        setRemoteOptions(responseData);
      } catch (error: unknown) {
        console.error('Error fetching options:', error);
        setRemoteOptions(undefined);
        addNotification({
          type: 'error',
          message: `${t('errors.options.load')} ${t('entities.gggg.a_id')}`,
          details: error instanceof Error ? error.message : undefined,
          techDetails: error instanceof HttpError ? error.details : undefined,
          duration: 10000,
        });
      }
      setLoading(false);
    };
    fetchOptions();
  }, [optionsLoad?.url, addNotification, fetch, t]);

  useEffect(() => {
    // Set the default value for the select field
    if (defaultValue !== undefined) {
      setValue(
        fieldName,
        multiple && Array.isArray(defaultValue)
          ? defaultValue.map((val) => String(val))
          : String(defaultValue || '')
      );
    } else {
      setValue(fieldName, multiple ? [] : '');
    }
  }, [remoteOptions, options, [...[defaultValue]].join(','), fieldName, multiple, setValue]);

  const getOptions = () => {
    if (options) {
      return options.sort(optionsSorter);
    }
    if (remoteOptions) {
      return remoteOptions
        .map((item) => ({
          label: getLabel(item),
          value: getValue(item),
        }))
        .sort(optionsSorter);
    }
    return [];
  };

  if (defaultValue === undefined) defaultValue = getValues(fieldName);

  return (
    <>
      <FormLabel htmlFor={fieldName} label={label} validations={validations} />
      <div className={selectContainerClassName}>
        <select
          multiple={multiple}
          id={fieldName}
          size={size ?? (multiple ? Math.min(10, Math.max(5, getOptions().length)) + 1 : undefined)}
          {...register(fieldName, { required: required ? 'errors.validations.required' : false })}
          className={selectClassName(!!errors?.[fieldName]?.message)}
        >
          {!multiple && !loading && getOptions().length > 0 && (
            <option className={selectOptionClassName} value={''} disabled={required}></option>
          )}
          {loading ? (
            <option className={selectOptionClassName} disabled>
              {t('common.select.loading')}
            </option>
          ) : getOptions().length === 0 ? (
            <option className={selectOptionClassName} disabled>
              {t('common.select.noOptions')}
            </option>
          ) : (
            getOptions().map((op) => (
              <option className={selectOptionClassName} key={op.value} value={op.value}>
                {op.label}
              </option>
            ))
          )}
        </select>
        {!multiple && !(size && size > 1) && (
          <ChevronsUpDown aria-hidden="true" className={selectChevronClassName} />
        )}
      </div>
      <FormErrors errors={errors} fieldName={fieldName} />
    </>
  );
};

export { SelectField };
export type { ISelectFieldOption };
