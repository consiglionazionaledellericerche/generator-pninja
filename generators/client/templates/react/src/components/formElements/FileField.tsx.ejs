import { useTranslation } from 'react-i18next';
import prettyBytes from 'pretty-bytes';
import { FileIcon, FileImageIcon, EditIcon, Trash2Icon, Undo2Icon, InfoIcon } from 'lucide-react';
import { useState, useRef } from 'react';
import { useFormContext, useController, FieldError } from 'react-hook-form';
import { FormLabelAria as FormLabel, FormFieldInfo } from './index';
import { useId } from 'react-aria';

type TransformedFileData = {
  data: string;
  mimeType: string;
  originalName: string;
  size: number;
  delete: boolean;
};

interface FileFieldProps {
  accept?: string;
  entity?: unknown;
  fieldName: string;
  label: string;
  validations?: {
    required?: boolean;
    minbytes?: number;
    maxbytes?: number;
  };
}

function fileToBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result;
      if (typeof result !== 'string') {
        reject('Failed to read file as data URL');
        return;
      }
      // Removes "data:mime/type;base64," and keeps only the base64
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = () => reject('Error reading file');
    reader.readAsDataURL(file);
  });
}

const FileField: React.FC<FileFieldProps> = ({ accept, entity, fieldName, label, validations }) => {
  const { t } = useTranslation();
  const entityData = entity as Record<string, unknown>;
  const hasFile = entityData?.[`${fieldName}_name`] || false;
  const [shouldShowInput, setShouldShowInput] = useState(!hasFile);
  const [isMarkedForDeletion, setIsMarkedForDeletion] = useState(false);
  const { required, minbytes, maxbytes } = validations || {};
  const inputRef = useRef<HTMLInputElement>(null);
  const {
    control,
    register,
    setValue,
    trigger,
    formState: { errors },
  } = useFormContext();

  const {
    fieldState: { error },
  } = useController({
    name: fieldName,
    control,
    rules: {},
  });

  const markForDeletion = (mark: boolean) => {
    setIsMarkedForDeletion(mark);
    setValue(fieldName, mark ? { delete: true } : null);
    setTimeout(() => {
      trigger(fieldName);
    }, 0);
  };

  const registerProps = register(fieldName, {
    validate: (value: unknown | undefined) => {
      const fileData = value as TransformedFileData | null;

      if (fileData?.mimeType && !fileData.mimeType.startsWith(accept?.replace(/\/\*$/, '') ?? '')) {
        return `errors.validations.file.invalidType:${accept}:${fileData.mimeType}`;
      }
      if (typeof fileData?.size === 'number' && minbytes && fileData?.size < minbytes) {
        return `errors.validations.file.minSize:${prettyBytes(minbytes)}:${prettyBytes(fileData?.size)}`;
      }
      if (typeof fileData?.size === 'number' && maxbytes && fileData?.size > maxbytes) {
        return `errors.validations.file.maxSize:${prettyBytes(maxbytes)}:${prettyBytes(fileData?.size)}`;
      }
      if (required && (fileData?.delete || (!fileData && !entityData?.[`${fieldName}_name`]))) {
        return 'errors.validations.file.required';
      }
      return true;
    },
  });

  // Handler personalizzato per trasformare e salvare
  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;

    if (!file) {
      setValue(fieldName, null);
      setTimeout(() => {
        trigger(fieldName);
      }, 0);
      return;
    }

    try {
      const fileData = await fileToBase64(file);
      const transformedValue: TransformedFileData = {
        data: fileData,
        mimeType: file.type,
        originalName: file.name,
        size: file.size,
        delete: isMarkedForDeletion,
      };

      setValue(fieldName, transformedValue);
      setTimeout(() => {
        trigger(fieldName);
      }, 0);
    } catch (error) {
      console.error('Error converting file to base64:', error);
      setValue(fieldName, null);
      setTimeout(() => {
        trigger(fieldName);
      }, 0);
    }
  };

  const undoEdit = () => {
    setShouldShowInput(false);
    setValue(fieldName, null);
    // Reset the input value
    const input = document.querySelector(`[name=${fieldName}]`) as HTMLInputElement;
    if (input) input.value = '';
    setTimeout(() => {
      trigger(fieldName);
    }, 0);
  };

  const fieldId = useId();
  const labelId = useId();
  const errorId = useId();
  const descriptionId = useId();

  return (
    <>
      <FormLabel id={labelId} validations={validations}>
        {label}
      </FormLabel>
      <div>
        {hasFile && !shouldShowInput && !isMarkedForDeletion && (
          <div className="p-3 bg-slate-200 text-slate-800 dark:bg-slate-600 dark:text-slate-200 rounded-md">
            <div className="flex items-center justify-between">
              <a
                href={`${location.pathname.replace('entities', 'api').replace('edit/', '')}/${fieldName}/${entityData?.[`${fieldName}_name`]}`}
                className="hover:underline flex items-center"
                target="_blank"
                rel="noopener noreferrer"
                aria-label={`${t('actions.crud.file.viewOrDownload')} ${entityData?.[`${fieldName}_name`]} (${t('common.opensInNewWindow')})`}
              >
                {(entityData?.[`${fieldName}_type`] as string)?.startsWith('image/') ? (
                  <FileImageIcon aria-hidden className="me-2 h-4 w-4" />
                ) : (
                  <FileIcon aria-hidden className="me-2 h-4 w-4" />
                )}
                {t('actions.crud.file.viewOrDownload')}{' '}
                {entityData?.[`${fieldName}_name`] as string} ({t('common.opensInNewWindow')})
              </a>
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  onClick={() => setShouldShowInput(true)}
                  className="flex items-center text-sm  cursor-pointer font-medium"
                >
                  <EditIcon aria-hidden className="me-1 h-4 w-4" />
                  {t('actions.crud.edit')}
                </button>
                <button
                  type="button"
                  onClick={() => markForDeletion(true)}
                  className="flex items-center text-sm  cursor-pointer font-medium"
                >
                  <Trash2Icon aria-hidden className="me-1 h-4 w-4" />
                  {t('actions.crud.delete')}
                </button>
              </div>
            </div>
          </div>
        )}

        {isMarkedForDeletion && (
          <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md">
            <div className="flex items-center justify-between">
              <div className="flex items-center text-red-800 dark:text-red-200">
                <Trash2Icon aria-hidden className="me-2 h-4 w-4" />
                <span className="text-sm font-medium">
                  {t('actions.crud.file.markedForDeletion')}
                </span>
              </div>
              <button
                type="button"
                onClick={() => markForDeletion(false)}
                className="flex items-center text-sm cursor-pointer font-medium"
              >
                <Undo2Icon aria-hidden className="me-2 h-4 w-4" />
                {t('common.undo')}
              </button>
            </div>
          </div>
        )}

        <div className={shouldShowInput && !isMarkedForDeletion ? 'block' : 'hidden'}>
          {hasFile && shouldShowInput && (
            <div className="p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-md">
              <div className="flex items-center justify-between">
                <div className="flex items-center text-yellow-800 dark:text-yellow-200">
                  <InfoIcon aria-hidden className="me-2 h-4 w-4" />
                  <span className="text-sm font-medium">
                    {t('actions.crud.file.replaceWarning')}
                  </span>
                </div>
                <button
                  type="button"
                  onClick={() => undoEdit()}
                  className="flex items-center text-sm cursor-pointer font-medium"
                >
                  <Undo2Icon aria-hidden className="me-2 h-4 w-4" />
                  {t('common.cancel')}
                </button>
              </div>
            </div>
          )}
          <input
            type="file"
            required={required && !hasFile && !isMarkedForDeletion}
            aria-invalid={!!error}
            aria-labelledby={labelId}
            aria-describedby={
              [validations ? descriptionId : '', error ? errorId : ''].join(' ').trim() || undefined
            }
            id={fieldId}
            accept={accept ?? '*/*'}
            {...registerProps}
            onChange={handleFileChange}
            ref={inputRef}
            className={errors?.[fieldName]?.message ? 'form-field-error' : 'form-field'}
          />
        </div>
      </div>
      {validations && <FormFieldInfo id={descriptionId} validations={validations || {}} />}
      {error && <Error id={errorId} error={error} />}
    </>
  );
};

const Error: React.FC<{ error: FieldError; id: string }> = ({ error, id }) => {
  const { t } = useTranslation();
  if (!error?.message) return null;
  const [message, accepted, actual] = error.message.split(':') || [];
  return (
    <p
      id={id}
      role="alert"
      className="block mt-1 text-sm bg-slate-50 dark:bg-slate-900 text-red-600 dark:text-red-500"
    >
      {t(message, { accepted, actual: actual })}
    </p>
  );
};

export { FileField };
