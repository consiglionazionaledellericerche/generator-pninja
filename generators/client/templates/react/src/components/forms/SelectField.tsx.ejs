import { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { ChevronsUpDown } from 'lucide-react';
import { UseFormReturn } from 'react-hook-form';
import { FormLabel } from './FormLabel';
import { FormErrors } from './FormErrors';
import { useNotifications } from '../../contexts/NotificationContext';
import { useApi } from '../../hooks/useApi';
import { HttpError } from '../../hooks/useApi';

const selectContainerClassName = 'grid grid-cols-1';
const selectClassName = (hasErrors = false) =>
  `scheme-light dark:scheme-dark outline-0${hasErrors ? ' outline-2 -outline-offset-2 outline-red-500' : ''} focus:outline-2 focus:-outline-offset-2 ${hasErrors ? 'focus:outline-red-500' : 'focus:outline-blue-600'} rounded-md block w-full mt-3 border-none bg-slate-200 text-slate-900 dark:bg-gray-800 dark:text-gray-300 text-sm/6 py-1.5 p-2 text-base appearance-none col-start-1 row-start-1`;
const selectOptionClassName = `scheme-light dark:scheme-dark outline-0 hover:outline-2 hover:-outline-offset-2 hover:outline-blue-600 focus:outline-2 focus:-outline-offset-2 focus:outline-blue-600 rounded-md mt-1 border-none bg-slate-200 text-slate-900 dark:bg-gray-800 dark:text-gray-300 text-sm/6 py-1.5 px-3 text-base appearance-none checked:bg-slate-300 checked:text-black dark:checked:bg-gray-700 dark:checked:text-white`;
const selectChevronClassName =
  'pointer-events-none col-start-1 row-start-1 mt-3 mr-2 size-5 self-center justify-self-end text-gray-500 sm:size-4';

interface ISelectFieldOption {
  label: number | string;
  value: number | string;
}

interface ISelectFieldOptionsLoad {
  url: string;
  valueAttribute?: string;
  getValue?: (item: Record<string, unknown>) => string | undefined;
  labelAttribute?: string;
  getLabel?: (item: Record<string, unknown>) => string | undefined;
}

interface SelectFieldProps {
  fieldName: string;
  formMethods: UseFormReturn;
  label: string;
  loadingOptions?: boolean;
  multiple?: boolean;
  options?: ISelectFieldOption[];
  optionsLoad?: ISelectFieldOptionsLoad;
  size?: number;
  validations?: {
    required?: boolean;
  };
  defaultValue?: (number | undefined | string) | (number | undefined | string)[] | undefined;
}

const optionsLoadAreEqual = (
  a: ISelectFieldOptionsLoad | undefined,
  b: ISelectFieldOptionsLoad | undefined
): boolean => {
  if (a === undefined && b === undefined) return true;
  return (
    a?.url === b?.url &&
    a?.valueAttribute === b?.valueAttribute &&
    a?.labelAttribute === b?.labelAttribute &&
    a?.getValue?.toString() === b?.getValue?.toString() &&
    a?.getLabel?.toString() === b?.getLabel?.toString()
  );
};

const areSelectFieldOptionArraysEqual = (
  arr1: ISelectFieldOption[],
  arr2: ISelectFieldOption[]
): boolean => {
  if (arr1.length !== arr2.length) return false;

  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i].label !== arr2[i].label || arr1[i].value !== arr2[i].value) {
      return false;
    }
  }

  return true;
};

const arraysHaveSameElements = (
  arr1: (string | number | null | undefined)[] | null | undefined,
  arr2: (string | number | null | undefined)[] | null | undefined
) => {
  if (arr1 === undefined && arr2 === undefined) return true;
  if (arr1 === undefined || arr2 === undefined) return false;
  if (arr1 === null && arr2 === null) return true;
  if (arr1 === null || arr2 === null) return false;
  if (arr1.length === 0 && arr2.length === 0) return true;
  if (arr1.length !== arr2.length) return false;
  const sorted1 = [...arr1].sort();
  const sorted2 = [...arr2].sort();
  for (let i = 0; i < sorted1.length; i++) {
    if (sorted1[i] !== sorted2[i]) return false;
  }
  return true;
};

const valuesAreEqual = (
  v: string | number | (string | number | undefined | null)[] | undefined | null,
  w: string | number | (string | number | undefined | null)[] | undefined | null
) => {
  if (v === undefined && w === undefined) return true;
  if (v === undefined || w === undefined) return false;
  if (Array.isArray(v) && Array.isArray(w)) {
    return arraysHaveSameElements(v, w);
  }
  return String(v) === String(w);
};

const SelectField: React.FC<SelectFieldProps> = ({
  fieldName,
  formMethods,
  label,
  multiple = false,
  options,
  optionsLoad,
  size,
  validations,
  defaultValue,
}) => {
  const { t } = useTranslation();
  const { addNotification } = useNotifications();
  const { required } = validations || {};
  const { fetch } = useApi();
  const [opts, setOpts] = useState<ISelectFieldOption[] | undefined>(undefined);
  const [loading, setLoading] = useState(false);
  const [currentSelectFieldOptionsLoad, setCurrentSelectFieldOptionsLoad] = useState<
    ISelectFieldOptionsLoad | undefined
  >(undefined);
  const [currentOptions, setCurrentOptions] = useState<ISelectFieldOption[] | undefined>(undefined);
  const [currentDefaultValue, setCurrentDefaultValue] = useState<
    (number | undefined | string) | (number | undefined | string)[] | undefined
  >(undefined);
  const {
    register,
    formState: { errors },
    setValue,
  } = formMethods;

  useEffect(() => {
    const setDefaultValue = (
      value: (number | undefined | string) | (number | undefined | string)[] | undefined
    ) => {
      if (value !== undefined) {
        setValue(fieldName, Array.isArray(value) ? value.map((val) => String(val)) : String(value));
      } else {
        setValue(fieldName, undefined);
      }
    };
    if (
      optionsLoadAreEqual(currentSelectFieldOptionsLoad, optionsLoad) &&
      areSelectFieldOptionArraysEqual(currentOptions ?? [], options ?? []) &&
      valuesAreEqual(currentDefaultValue, defaultValue)
    ) {
      return;
    }
    if (options) {
      setDefaultValue(defaultValue);
      setCurrentSelectFieldOptionsLoad(optionsLoad);
      setCurrentOptions(options);
      setCurrentDefaultValue(defaultValue);
    }
    if (!optionsLoad?.url) return;
    const fetchOptions = async () => {
      setLoading(true);
      try {
        const reponse = await fetch(optionsLoad?.url ?? '');
        const responseData = await reponse.json();
        const loadedOptions = responseData
          .map((item: Record<string, unknown>) => ({
            value: optionsLoad?.getValue
              ? optionsLoad?.getValue(item)
              : item[optionsLoad?.valueAttribute ?? 'id'],
            label: optionsLoad?.getLabel
              ? optionsLoad?.getLabel(item)
              : item[optionsLoad?.labelAttribute ?? optionsLoad?.valueAttribute ?? 'id'],
          }))
          .sort((a: ISelectFieldOption, b: ISelectFieldOption) =>
            String(a.label).localeCompare(String(b.label), undefined, { numeric: true })
          );

        setOpts(loadedOptions);
        setDefaultValue(defaultValue);
      } catch (error: unknown) {
        console.error('Error fetching options:', error);
        setOpts(undefined);
        addNotification({
          type: 'error',
          message: `${t('errors.options.load')} ${t('entities.gggg.a_id')}`,
          details: error instanceof Error ? error.message : undefined,
          techDetails: error instanceof HttpError ? error.details : undefined,
          duration: 10000,
        });
      }
      setCurrentSelectFieldOptionsLoad(optionsLoad);
      setCurrentOptions(options);
      setCurrentDefaultValue(defaultValue);
      setLoading(false);
    };

    fetchOptions();
  }, [
    fetch,
    addNotification,
    t,
    optionsLoad,
    defaultValue,
    fieldName,
    setValue,
    options,
    currentSelectFieldOptionsLoad,
    currentOptions,
    currentDefaultValue,
  ]);

  return (
    <>
      <FormLabel htmlFor={fieldName} label={label} validations={validations} />
      <div className={selectContainerClassName}>
        <select
          multiple={multiple}
          id={fieldName}
          size={
            size ??
            (multiple ? Math.min(10, Math.max(5, (opts ?? options ?? []).length)) + 1 : undefined)
          }
          {...register(fieldName, { required: required ? 'errors.validations.required' : false })}
          className={selectClassName(!!errors?.[fieldName]?.message)}
        >
          {!multiple && !loading && (opts ?? options ?? []).length > 0 && (
            <option className={selectOptionClassName} value={''} disabled={required}></option>
          )}
          {loading ? (
            <option className={selectOptionClassName} disabled>
              {t('common.select.loading')}
            </option>
          ) : (opts ?? options ?? []).length === 0 ? (
            <option className={selectOptionClassName} disabled>
              {t('common.select.noOptions')}
            </option>
          ) : (
            (opts ?? options ?? []).map((op) => (
              <option className={selectOptionClassName} key={op.value} value={op.value}>
                {op.label}
              </option>
            ))
          )}
        </select>
        {!multiple && !(size && size > 1) && (
          <ChevronsUpDown aria-hidden="true" className={selectChevronClassName} />
        )}
      </div>
      <FormErrors errors={errors} fieldName={fieldName} />
    </>
  );
};

export { SelectField };
export type { ISelectFieldOption };
