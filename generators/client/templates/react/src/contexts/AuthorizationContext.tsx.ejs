import React, { createContext, useContext, useState, useCallback, useRef, ReactNode } from 'react';
import axios from 'axios';

interface AuthorizationContextType {
  can: (resource: string, action: string) => Promise<boolean>;
  refresh: () => void;
}

interface CacheEntry {
  allowed: boolean;
  timestamp: number;
}

const AuthorizationContext = createContext<AuthorizationContextType | undefined>(undefined);

interface AuthorizationProviderProps {
  children: ReactNode;
  cacheDuration?: number;
}

export const AuthorizationProvider: React.FC<AuthorizationProviderProps> = ({
  children,
  cacheDuration = 1 * 1000,
}) => {
  const [cache, setCache] = useState<Map<string, CacheEntry>>(new Map());
  const pendingRequestsRef = useRef<Map<string, Promise<boolean>>>(new Map());

  const getCacheKey = (resource: string, action: string): string => {
    return `${resource}:${action}`;
  };

  const refresh = useCallback(() => {
    setCache(new Map());
    pendingRequestsRef.current = new Map();
  }, []);

  const can = useCallback(
    async (resource: string, action: string): Promise<boolean> => {
      const key = getCacheKey(resource, action);
      const now = Date.now();

      // 1. Controlla cache
      const cached = cache.get(key);
      if (cached && now - cached.timestamp < cacheDuration) {
        return cached.allowed;
      }

      // 2. Controlla se c'è già una richiesta in corso (SINCRONO con ref)
      const pending = pendingRequestsRef.current.get(key);
      if (pending) {
        return pending;
      }

      // 3. Crea nuova richiesta
      const request = axios
        .post<{ allowed: boolean }>('/api/user/can', {
          resource,
          action,
        })
        .then((response) => {
          const allowed = response.data.allowed;

          // Aggiorna cache
          setCache((prev) =>
            new Map(prev).set(key, {
              allowed,
              timestamp: now,
            })
          );

          // Rimuovi dalla pending (SINCRONO)
          pendingRequestsRef.current.delete(key);

          return allowed;
        })
        .catch(() => {
          // Rimuovi dalla pending anche in caso di errore
          pendingRequestsRef.current.delete(key);
          return false;
        });

      // Salva la promise come pending (SINCRONO)
      pendingRequestsRef.current.set(key, request);

      return request;
    },
    [cache, cacheDuration]
  );

  return (
    <AuthorizationContext.Provider value={{ can, refresh }}>
      {children}
    </AuthorizationContext.Provider>
  );
};

export const useAuthorization = (): AuthorizationContextType => {
  const context = useContext(AuthorizationContext);
  if (!context) {
    throw new Error('useAuthorization must be used within AuthorizationProvider');
  }
  return context;
};
